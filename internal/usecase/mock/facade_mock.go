// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i gitlab.ozon.dev/marchenkosasha2/homework/internal/usecase.Facade -o facade_mock.go -n FacadeMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/marchenkosasha2/homework/internal/dto"
)

// FacadeMock implements mm_usecase.Facade
type FacadeMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddOrder          func(ctx context.Context, orderDTO dto.OrderDTO) (err error)
	funcAddOrderOrigin    string
	inspectFuncAddOrder   func(ctx context.Context, orderDTO dto.OrderDTO)
	afterAddOrderCounter  uint64
	beforeAddOrderCounter uint64
	AddOrderMock          mFacadeMockAddOrder

	funcGetClientOrdersList          func(ctx context.Context, clientID int) (lp1 *dto.ListOrdersDTO, err error)
	funcGetClientOrdersListOrigin    string
	inspectFuncGetClientOrdersList   func(ctx context.Context, clientID int)
	afterGetClientOrdersListCounter  uint64
	beforeGetClientOrdersListCounter uint64
	GetClientOrdersListMock          mFacadeMockGetClientOrdersList

	funcGetOrderByID          func(ctx context.Context, id int) (op1 *dto.OrderDTO, err error)
	funcGetOrderByIDOrigin    string
	inspectFuncGetOrderByID   func(ctx context.Context, id int)
	afterGetOrderByIDCounter  uint64
	beforeGetOrderByIDCounter uint64
	GetOrderByIDMock          mFacadeMockGetOrderByID

	funcGetOrdersByID          func(ctx context.Context, ids []int) (lp1 *dto.ListOrdersDTO, err error)
	funcGetOrdersByIDOrigin    string
	inspectFuncGetOrdersByID   func(ctx context.Context, ids []int)
	afterGetOrdersByIDCounter  uint64
	beforeGetOrdersByIDCounter uint64
	GetOrdersByIDMock          mFacadeMockGetOrdersByID

	funcGetRefundsList          func(ctx context.Context, limit int, offset int) (lp1 *dto.ListOrdersDTO, err error)
	funcGetRefundsListOrigin    string
	inspectFuncGetRefundsList   func(ctx context.Context, limit int, offset int)
	afterGetRefundsListCounter  uint64
	beforeGetRefundsListCounter uint64
	GetRefundsListMock          mFacadeMockGetRefundsList

	funcUpdateOrder          func(ctx context.Context, orderDTO dto.OrderDTO) (err error)
	funcUpdateOrderOrigin    string
	inspectFuncUpdateOrder   func(ctx context.Context, orderDTO dto.OrderDTO)
	afterUpdateOrderCounter  uint64
	beforeUpdateOrderCounter uint64
	UpdateOrderMock          mFacadeMockUpdateOrder
}

// NewFacadeMock returns a mock for mm_usecase.Facade
func NewFacadeMock(t minimock.Tester) *FacadeMock {
	m := &FacadeMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddOrderMock = mFacadeMockAddOrder{mock: m}
	m.AddOrderMock.callArgs = []*FacadeMockAddOrderParams{}

	m.GetClientOrdersListMock = mFacadeMockGetClientOrdersList{mock: m}
	m.GetClientOrdersListMock.callArgs = []*FacadeMockGetClientOrdersListParams{}

	m.GetOrderByIDMock = mFacadeMockGetOrderByID{mock: m}
	m.GetOrderByIDMock.callArgs = []*FacadeMockGetOrderByIDParams{}

	m.GetOrdersByIDMock = mFacadeMockGetOrdersByID{mock: m}
	m.GetOrdersByIDMock.callArgs = []*FacadeMockGetOrdersByIDParams{}

	m.GetRefundsListMock = mFacadeMockGetRefundsList{mock: m}
	m.GetRefundsListMock.callArgs = []*FacadeMockGetRefundsListParams{}

	m.UpdateOrderMock = mFacadeMockUpdateOrder{mock: m}
	m.UpdateOrderMock.callArgs = []*FacadeMockUpdateOrderParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mFacadeMockAddOrder struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockAddOrderExpectation
	expectations       []*FacadeMockAddOrderExpectation

	callArgs []*FacadeMockAddOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockAddOrderExpectation specifies expectation struct of the Facade.AddOrder
type FacadeMockAddOrderExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockAddOrderParams
	paramPtrs          *FacadeMockAddOrderParamPtrs
	expectationOrigins FacadeMockAddOrderExpectationOrigins
	results            *FacadeMockAddOrderResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockAddOrderParams contains parameters of the Facade.AddOrder
type FacadeMockAddOrderParams struct {
	ctx      context.Context
	orderDTO dto.OrderDTO
}

// FacadeMockAddOrderParamPtrs contains pointers to parameters of the Facade.AddOrder
type FacadeMockAddOrderParamPtrs struct {
	ctx      *context.Context
	orderDTO *dto.OrderDTO
}

// FacadeMockAddOrderResults contains results of the Facade.AddOrder
type FacadeMockAddOrderResults struct {
	err error
}

// FacadeMockAddOrderOrigins contains origins of expectations of the Facade.AddOrder
type FacadeMockAddOrderExpectationOrigins struct {
	origin         string
	originCtx      string
	originOrderDTO string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddOrder *mFacadeMockAddOrder) Optional() *mFacadeMockAddOrder {
	mmAddOrder.optional = true
	return mmAddOrder
}

// Expect sets up expected params for Facade.AddOrder
func (mmAddOrder *mFacadeMockAddOrder) Expect(ctx context.Context, orderDTO dto.OrderDTO) *mFacadeMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &FacadeMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.paramPtrs != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by ExpectParams functions")
	}

	mmAddOrder.defaultExpectation.params = &FacadeMockAddOrderParams{ctx, orderDTO}
	mmAddOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddOrder.expectations {
		if minimock.Equal(e.params, mmAddOrder.defaultExpectation.params) {
			mmAddOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddOrder.defaultExpectation.params)
		}
	}

	return mmAddOrder
}

// ExpectCtxParam1 sets up expected param ctx for Facade.AddOrder
func (mmAddOrder *mFacadeMockAddOrder) ExpectCtxParam1(ctx context.Context) *mFacadeMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &FacadeMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &FacadeMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddOrder
}

// ExpectOrderDTOParam2 sets up expected param orderDTO for Facade.AddOrder
func (mmAddOrder *mFacadeMockAddOrder) ExpectOrderDTOParam2(orderDTO dto.OrderDTO) *mFacadeMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &FacadeMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &FacadeMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.orderDTO = &orderDTO
	mmAddOrder.defaultExpectation.expectationOrigins.originOrderDTO = minimock.CallerInfo(1)

	return mmAddOrder
}

// Inspect accepts an inspector function that has same arguments as the Facade.AddOrder
func (mmAddOrder *mFacadeMockAddOrder) Inspect(f func(ctx context.Context, orderDTO dto.OrderDTO)) *mFacadeMockAddOrder {
	if mmAddOrder.mock.inspectFuncAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("Inspect function is already set for FacadeMock.AddOrder")
	}

	mmAddOrder.mock.inspectFuncAddOrder = f

	return mmAddOrder
}

// Return sets up results that will be returned by Facade.AddOrder
func (mmAddOrder *mFacadeMockAddOrder) Return(err error) *FacadeMock {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &FacadeMockAddOrderExpectation{mock: mmAddOrder.mock}
	}
	mmAddOrder.defaultExpectation.results = &FacadeMockAddOrderResults{err}
	mmAddOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddOrder.mock
}

// Set uses given function f to mock the Facade.AddOrder method
func (mmAddOrder *mFacadeMockAddOrder) Set(f func(ctx context.Context, orderDTO dto.OrderDTO) (err error)) *FacadeMock {
	if mmAddOrder.defaultExpectation != nil {
		mmAddOrder.mock.t.Fatalf("Default expectation is already set for the Facade.AddOrder method")
	}

	if len(mmAddOrder.expectations) > 0 {
		mmAddOrder.mock.t.Fatalf("Some expectations are already set for the Facade.AddOrder method")
	}

	mmAddOrder.mock.funcAddOrder = f
	mmAddOrder.mock.funcAddOrderOrigin = minimock.CallerInfo(1)
	return mmAddOrder.mock
}

// When sets expectation for the Facade.AddOrder which will trigger the result defined by the following
// Then helper
func (mmAddOrder *mFacadeMockAddOrder) When(ctx context.Context, orderDTO dto.OrderDTO) *FacadeMockAddOrderExpectation {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("FacadeMock.AddOrder mock is already set by Set")
	}

	expectation := &FacadeMockAddOrderExpectation{
		mock:               mmAddOrder.mock,
		params:             &FacadeMockAddOrderParams{ctx, orderDTO},
		expectationOrigins: FacadeMockAddOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddOrder.expectations = append(mmAddOrder.expectations, expectation)
	return expectation
}

// Then sets up Facade.AddOrder return parameters for the expectation previously defined by the When method
func (e *FacadeMockAddOrderExpectation) Then(err error) *FacadeMock {
	e.results = &FacadeMockAddOrderResults{err}
	return e.mock
}

// Times sets number of times Facade.AddOrder should be invoked
func (mmAddOrder *mFacadeMockAddOrder) Times(n uint64) *mFacadeMockAddOrder {
	if n == 0 {
		mmAddOrder.mock.t.Fatalf("Times of FacadeMock.AddOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddOrder.expectedInvocations, n)
	mmAddOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddOrder
}

func (mmAddOrder *mFacadeMockAddOrder) invocationsDone() bool {
	if len(mmAddOrder.expectations) == 0 && mmAddOrder.defaultExpectation == nil && mmAddOrder.mock.funcAddOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddOrder.mock.afterAddOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddOrder implements mm_usecase.Facade
func (mmAddOrder *FacadeMock) AddOrder(ctx context.Context, orderDTO dto.OrderDTO) (err error) {
	mm_atomic.AddUint64(&mmAddOrder.beforeAddOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmAddOrder.afterAddOrderCounter, 1)

	mmAddOrder.t.Helper()

	if mmAddOrder.inspectFuncAddOrder != nil {
		mmAddOrder.inspectFuncAddOrder(ctx, orderDTO)
	}

	mm_params := FacadeMockAddOrderParams{ctx, orderDTO}

	// Record call args
	mmAddOrder.AddOrderMock.mutex.Lock()
	mmAddOrder.AddOrderMock.callArgs = append(mmAddOrder.AddOrderMock.callArgs, &mm_params)
	mmAddOrder.AddOrderMock.mutex.Unlock()

	for _, e := range mmAddOrder.AddOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddOrder.AddOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddOrder.AddOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmAddOrder.AddOrderMock.defaultExpectation.params
		mm_want_ptrs := mmAddOrder.AddOrderMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockAddOrderParams{ctx, orderDTO}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddOrder.t.Errorf("FacadeMock.AddOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderDTO != nil && !minimock.Equal(*mm_want_ptrs.orderDTO, mm_got.orderDTO) {
				mmAddOrder.t.Errorf("FacadeMock.AddOrder got unexpected parameter orderDTO, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.originOrderDTO, *mm_want_ptrs.orderDTO, mm_got.orderDTO, minimock.Diff(*mm_want_ptrs.orderDTO, mm_got.orderDTO))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddOrder.t.Errorf("FacadeMock.AddOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddOrder.AddOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmAddOrder.t.Fatal("No results are set for the FacadeMock.AddOrder")
		}
		return (*mm_results).err
	}
	if mmAddOrder.funcAddOrder != nil {
		return mmAddOrder.funcAddOrder(ctx, orderDTO)
	}
	mmAddOrder.t.Fatalf("Unexpected call to FacadeMock.AddOrder. %v %v", ctx, orderDTO)
	return
}

// AddOrderAfterCounter returns a count of finished FacadeMock.AddOrder invocations
func (mmAddOrder *FacadeMock) AddOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrder.afterAddOrderCounter)
}

// AddOrderBeforeCounter returns a count of FacadeMock.AddOrder invocations
func (mmAddOrder *FacadeMock) AddOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrder.beforeAddOrderCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.AddOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddOrder *mFacadeMockAddOrder) Calls() []*FacadeMockAddOrderParams {
	mmAddOrder.mutex.RLock()

	argCopy := make([]*FacadeMockAddOrderParams, len(mmAddOrder.callArgs))
	copy(argCopy, mmAddOrder.callArgs)

	mmAddOrder.mutex.RUnlock()

	return argCopy
}

// MinimockAddOrderDone returns true if the count of the AddOrder invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockAddOrderDone() bool {
	if m.AddOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddOrderMock.invocationsDone()
}

// MinimockAddOrderInspect logs each unmet expectation
func (m *FacadeMock) MinimockAddOrderInspect() {
	for _, e := range m.AddOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.AddOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddOrderCounter := mm_atomic.LoadUint64(&m.afterAddOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddOrderMock.defaultExpectation != nil && afterAddOrderCounter < 1 {
		if m.AddOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.AddOrder at\n%s", m.AddOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.AddOrder at\n%s with params: %#v", m.AddOrderMock.defaultExpectation.expectationOrigins.origin, *m.AddOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddOrder != nil && afterAddOrderCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.AddOrder at\n%s", m.funcAddOrderOrigin)
	}

	if !m.AddOrderMock.invocationsDone() && afterAddOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.AddOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddOrderMock.expectedInvocations), m.AddOrderMock.expectedInvocationsOrigin, afterAddOrderCounter)
	}
}

type mFacadeMockGetClientOrdersList struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockGetClientOrdersListExpectation
	expectations       []*FacadeMockGetClientOrdersListExpectation

	callArgs []*FacadeMockGetClientOrdersListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockGetClientOrdersListExpectation specifies expectation struct of the Facade.GetClientOrdersList
type FacadeMockGetClientOrdersListExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockGetClientOrdersListParams
	paramPtrs          *FacadeMockGetClientOrdersListParamPtrs
	expectationOrigins FacadeMockGetClientOrdersListExpectationOrigins
	results            *FacadeMockGetClientOrdersListResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockGetClientOrdersListParams contains parameters of the Facade.GetClientOrdersList
type FacadeMockGetClientOrdersListParams struct {
	ctx      context.Context
	clientID int
}

// FacadeMockGetClientOrdersListParamPtrs contains pointers to parameters of the Facade.GetClientOrdersList
type FacadeMockGetClientOrdersListParamPtrs struct {
	ctx      *context.Context
	clientID *int
}

// FacadeMockGetClientOrdersListResults contains results of the Facade.GetClientOrdersList
type FacadeMockGetClientOrdersListResults struct {
	lp1 *dto.ListOrdersDTO
	err error
}

// FacadeMockGetClientOrdersListOrigins contains origins of expectations of the Facade.GetClientOrdersList
type FacadeMockGetClientOrdersListExpectationOrigins struct {
	origin         string
	originCtx      string
	originClientID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetClientOrdersList *mFacadeMockGetClientOrdersList) Optional() *mFacadeMockGetClientOrdersList {
	mmGetClientOrdersList.optional = true
	return mmGetClientOrdersList
}

// Expect sets up expected params for Facade.GetClientOrdersList
func (mmGetClientOrdersList *mFacadeMockGetClientOrdersList) Expect(ctx context.Context, clientID int) *mFacadeMockGetClientOrdersList {
	if mmGetClientOrdersList.mock.funcGetClientOrdersList != nil {
		mmGetClientOrdersList.mock.t.Fatalf("FacadeMock.GetClientOrdersList mock is already set by Set")
	}

	if mmGetClientOrdersList.defaultExpectation == nil {
		mmGetClientOrdersList.defaultExpectation = &FacadeMockGetClientOrdersListExpectation{}
	}

	if mmGetClientOrdersList.defaultExpectation.paramPtrs != nil {
		mmGetClientOrdersList.mock.t.Fatalf("FacadeMock.GetClientOrdersList mock is already set by ExpectParams functions")
	}

	mmGetClientOrdersList.defaultExpectation.params = &FacadeMockGetClientOrdersListParams{ctx, clientID}
	mmGetClientOrdersList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetClientOrdersList.expectations {
		if minimock.Equal(e.params, mmGetClientOrdersList.defaultExpectation.params) {
			mmGetClientOrdersList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetClientOrdersList.defaultExpectation.params)
		}
	}

	return mmGetClientOrdersList
}

// ExpectCtxParam1 sets up expected param ctx for Facade.GetClientOrdersList
func (mmGetClientOrdersList *mFacadeMockGetClientOrdersList) ExpectCtxParam1(ctx context.Context) *mFacadeMockGetClientOrdersList {
	if mmGetClientOrdersList.mock.funcGetClientOrdersList != nil {
		mmGetClientOrdersList.mock.t.Fatalf("FacadeMock.GetClientOrdersList mock is already set by Set")
	}

	if mmGetClientOrdersList.defaultExpectation == nil {
		mmGetClientOrdersList.defaultExpectation = &FacadeMockGetClientOrdersListExpectation{}
	}

	if mmGetClientOrdersList.defaultExpectation.params != nil {
		mmGetClientOrdersList.mock.t.Fatalf("FacadeMock.GetClientOrdersList mock is already set by Expect")
	}

	if mmGetClientOrdersList.defaultExpectation.paramPtrs == nil {
		mmGetClientOrdersList.defaultExpectation.paramPtrs = &FacadeMockGetClientOrdersListParamPtrs{}
	}
	mmGetClientOrdersList.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetClientOrdersList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetClientOrdersList
}

// ExpectClientIDParam2 sets up expected param clientID for Facade.GetClientOrdersList
func (mmGetClientOrdersList *mFacadeMockGetClientOrdersList) ExpectClientIDParam2(clientID int) *mFacadeMockGetClientOrdersList {
	if mmGetClientOrdersList.mock.funcGetClientOrdersList != nil {
		mmGetClientOrdersList.mock.t.Fatalf("FacadeMock.GetClientOrdersList mock is already set by Set")
	}

	if mmGetClientOrdersList.defaultExpectation == nil {
		mmGetClientOrdersList.defaultExpectation = &FacadeMockGetClientOrdersListExpectation{}
	}

	if mmGetClientOrdersList.defaultExpectation.params != nil {
		mmGetClientOrdersList.mock.t.Fatalf("FacadeMock.GetClientOrdersList mock is already set by Expect")
	}

	if mmGetClientOrdersList.defaultExpectation.paramPtrs == nil {
		mmGetClientOrdersList.defaultExpectation.paramPtrs = &FacadeMockGetClientOrdersListParamPtrs{}
	}
	mmGetClientOrdersList.defaultExpectation.paramPtrs.clientID = &clientID
	mmGetClientOrdersList.defaultExpectation.expectationOrigins.originClientID = minimock.CallerInfo(1)

	return mmGetClientOrdersList
}

// Inspect accepts an inspector function that has same arguments as the Facade.GetClientOrdersList
func (mmGetClientOrdersList *mFacadeMockGetClientOrdersList) Inspect(f func(ctx context.Context, clientID int)) *mFacadeMockGetClientOrdersList {
	if mmGetClientOrdersList.mock.inspectFuncGetClientOrdersList != nil {
		mmGetClientOrdersList.mock.t.Fatalf("Inspect function is already set for FacadeMock.GetClientOrdersList")
	}

	mmGetClientOrdersList.mock.inspectFuncGetClientOrdersList = f

	return mmGetClientOrdersList
}

// Return sets up results that will be returned by Facade.GetClientOrdersList
func (mmGetClientOrdersList *mFacadeMockGetClientOrdersList) Return(lp1 *dto.ListOrdersDTO, err error) *FacadeMock {
	if mmGetClientOrdersList.mock.funcGetClientOrdersList != nil {
		mmGetClientOrdersList.mock.t.Fatalf("FacadeMock.GetClientOrdersList mock is already set by Set")
	}

	if mmGetClientOrdersList.defaultExpectation == nil {
		mmGetClientOrdersList.defaultExpectation = &FacadeMockGetClientOrdersListExpectation{mock: mmGetClientOrdersList.mock}
	}
	mmGetClientOrdersList.defaultExpectation.results = &FacadeMockGetClientOrdersListResults{lp1, err}
	mmGetClientOrdersList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetClientOrdersList.mock
}

// Set uses given function f to mock the Facade.GetClientOrdersList method
func (mmGetClientOrdersList *mFacadeMockGetClientOrdersList) Set(f func(ctx context.Context, clientID int) (lp1 *dto.ListOrdersDTO, err error)) *FacadeMock {
	if mmGetClientOrdersList.defaultExpectation != nil {
		mmGetClientOrdersList.mock.t.Fatalf("Default expectation is already set for the Facade.GetClientOrdersList method")
	}

	if len(mmGetClientOrdersList.expectations) > 0 {
		mmGetClientOrdersList.mock.t.Fatalf("Some expectations are already set for the Facade.GetClientOrdersList method")
	}

	mmGetClientOrdersList.mock.funcGetClientOrdersList = f
	mmGetClientOrdersList.mock.funcGetClientOrdersListOrigin = minimock.CallerInfo(1)
	return mmGetClientOrdersList.mock
}

// When sets expectation for the Facade.GetClientOrdersList which will trigger the result defined by the following
// Then helper
func (mmGetClientOrdersList *mFacadeMockGetClientOrdersList) When(ctx context.Context, clientID int) *FacadeMockGetClientOrdersListExpectation {
	if mmGetClientOrdersList.mock.funcGetClientOrdersList != nil {
		mmGetClientOrdersList.mock.t.Fatalf("FacadeMock.GetClientOrdersList mock is already set by Set")
	}

	expectation := &FacadeMockGetClientOrdersListExpectation{
		mock:               mmGetClientOrdersList.mock,
		params:             &FacadeMockGetClientOrdersListParams{ctx, clientID},
		expectationOrigins: FacadeMockGetClientOrdersListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetClientOrdersList.expectations = append(mmGetClientOrdersList.expectations, expectation)
	return expectation
}

// Then sets up Facade.GetClientOrdersList return parameters for the expectation previously defined by the When method
func (e *FacadeMockGetClientOrdersListExpectation) Then(lp1 *dto.ListOrdersDTO, err error) *FacadeMock {
	e.results = &FacadeMockGetClientOrdersListResults{lp1, err}
	return e.mock
}

// Times sets number of times Facade.GetClientOrdersList should be invoked
func (mmGetClientOrdersList *mFacadeMockGetClientOrdersList) Times(n uint64) *mFacadeMockGetClientOrdersList {
	if n == 0 {
		mmGetClientOrdersList.mock.t.Fatalf("Times of FacadeMock.GetClientOrdersList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetClientOrdersList.expectedInvocations, n)
	mmGetClientOrdersList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetClientOrdersList
}

func (mmGetClientOrdersList *mFacadeMockGetClientOrdersList) invocationsDone() bool {
	if len(mmGetClientOrdersList.expectations) == 0 && mmGetClientOrdersList.defaultExpectation == nil && mmGetClientOrdersList.mock.funcGetClientOrdersList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetClientOrdersList.mock.afterGetClientOrdersListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetClientOrdersList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetClientOrdersList implements mm_usecase.Facade
func (mmGetClientOrdersList *FacadeMock) GetClientOrdersList(ctx context.Context, clientID int) (lp1 *dto.ListOrdersDTO, err error) {
	mm_atomic.AddUint64(&mmGetClientOrdersList.beforeGetClientOrdersListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetClientOrdersList.afterGetClientOrdersListCounter, 1)

	mmGetClientOrdersList.t.Helper()

	if mmGetClientOrdersList.inspectFuncGetClientOrdersList != nil {
		mmGetClientOrdersList.inspectFuncGetClientOrdersList(ctx, clientID)
	}

	mm_params := FacadeMockGetClientOrdersListParams{ctx, clientID}

	// Record call args
	mmGetClientOrdersList.GetClientOrdersListMock.mutex.Lock()
	mmGetClientOrdersList.GetClientOrdersListMock.callArgs = append(mmGetClientOrdersList.GetClientOrdersListMock.callArgs, &mm_params)
	mmGetClientOrdersList.GetClientOrdersListMock.mutex.Unlock()

	for _, e := range mmGetClientOrdersList.GetClientOrdersListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation.Counter, 1)
		mm_want := mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation.params
		mm_want_ptrs := mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockGetClientOrdersListParams{ctx, clientID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetClientOrdersList.t.Errorf("FacadeMock.GetClientOrdersList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.clientID != nil && !minimock.Equal(*mm_want_ptrs.clientID, mm_got.clientID) {
				mmGetClientOrdersList.t.Errorf("FacadeMock.GetClientOrdersList got unexpected parameter clientID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation.expectationOrigins.originClientID, *mm_want_ptrs.clientID, mm_got.clientID, minimock.Diff(*mm_want_ptrs.clientID, mm_got.clientID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetClientOrdersList.t.Errorf("FacadeMock.GetClientOrdersList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetClientOrdersList.t.Fatal("No results are set for the FacadeMock.GetClientOrdersList")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmGetClientOrdersList.funcGetClientOrdersList != nil {
		return mmGetClientOrdersList.funcGetClientOrdersList(ctx, clientID)
	}
	mmGetClientOrdersList.t.Fatalf("Unexpected call to FacadeMock.GetClientOrdersList. %v %v", ctx, clientID)
	return
}

// GetClientOrdersListAfterCounter returns a count of finished FacadeMock.GetClientOrdersList invocations
func (mmGetClientOrdersList *FacadeMock) GetClientOrdersListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClientOrdersList.afterGetClientOrdersListCounter)
}

// GetClientOrdersListBeforeCounter returns a count of FacadeMock.GetClientOrdersList invocations
func (mmGetClientOrdersList *FacadeMock) GetClientOrdersListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClientOrdersList.beforeGetClientOrdersListCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.GetClientOrdersList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetClientOrdersList *mFacadeMockGetClientOrdersList) Calls() []*FacadeMockGetClientOrdersListParams {
	mmGetClientOrdersList.mutex.RLock()

	argCopy := make([]*FacadeMockGetClientOrdersListParams, len(mmGetClientOrdersList.callArgs))
	copy(argCopy, mmGetClientOrdersList.callArgs)

	mmGetClientOrdersList.mutex.RUnlock()

	return argCopy
}

// MinimockGetClientOrdersListDone returns true if the count of the GetClientOrdersList invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockGetClientOrdersListDone() bool {
	if m.GetClientOrdersListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetClientOrdersListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetClientOrdersListMock.invocationsDone()
}

// MinimockGetClientOrdersListInspect logs each unmet expectation
func (m *FacadeMock) MinimockGetClientOrdersListInspect() {
	for _, e := range m.GetClientOrdersListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.GetClientOrdersList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetClientOrdersListCounter := mm_atomic.LoadUint64(&m.afterGetClientOrdersListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetClientOrdersListMock.defaultExpectation != nil && afterGetClientOrdersListCounter < 1 {
		if m.GetClientOrdersListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.GetClientOrdersList at\n%s", m.GetClientOrdersListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.GetClientOrdersList at\n%s with params: %#v", m.GetClientOrdersListMock.defaultExpectation.expectationOrigins.origin, *m.GetClientOrdersListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetClientOrdersList != nil && afterGetClientOrdersListCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.GetClientOrdersList at\n%s", m.funcGetClientOrdersListOrigin)
	}

	if !m.GetClientOrdersListMock.invocationsDone() && afterGetClientOrdersListCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.GetClientOrdersList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetClientOrdersListMock.expectedInvocations), m.GetClientOrdersListMock.expectedInvocationsOrigin, afterGetClientOrdersListCounter)
	}
}

type mFacadeMockGetOrderByID struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockGetOrderByIDExpectation
	expectations       []*FacadeMockGetOrderByIDExpectation

	callArgs []*FacadeMockGetOrderByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockGetOrderByIDExpectation specifies expectation struct of the Facade.GetOrderByID
type FacadeMockGetOrderByIDExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockGetOrderByIDParams
	paramPtrs          *FacadeMockGetOrderByIDParamPtrs
	expectationOrigins FacadeMockGetOrderByIDExpectationOrigins
	results            *FacadeMockGetOrderByIDResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockGetOrderByIDParams contains parameters of the Facade.GetOrderByID
type FacadeMockGetOrderByIDParams struct {
	ctx context.Context
	id  int
}

// FacadeMockGetOrderByIDParamPtrs contains pointers to parameters of the Facade.GetOrderByID
type FacadeMockGetOrderByIDParamPtrs struct {
	ctx *context.Context
	id  *int
}

// FacadeMockGetOrderByIDResults contains results of the Facade.GetOrderByID
type FacadeMockGetOrderByIDResults struct {
	op1 *dto.OrderDTO
	err error
}

// FacadeMockGetOrderByIDOrigins contains origins of expectations of the Facade.GetOrderByID
type FacadeMockGetOrderByIDExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrderByID *mFacadeMockGetOrderByID) Optional() *mFacadeMockGetOrderByID {
	mmGetOrderByID.optional = true
	return mmGetOrderByID
}

// Expect sets up expected params for Facade.GetOrderByID
func (mmGetOrderByID *mFacadeMockGetOrderByID) Expect(ctx context.Context, id int) *mFacadeMockGetOrderByID {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("FacadeMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &FacadeMockGetOrderByIDExpectation{}
	}

	if mmGetOrderByID.defaultExpectation.paramPtrs != nil {
		mmGetOrderByID.mock.t.Fatalf("FacadeMock.GetOrderByID mock is already set by ExpectParams functions")
	}

	mmGetOrderByID.defaultExpectation.params = &FacadeMockGetOrderByIDParams{ctx, id}
	mmGetOrderByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrderByID.expectations {
		if minimock.Equal(e.params, mmGetOrderByID.defaultExpectation.params) {
			mmGetOrderByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrderByID.defaultExpectation.params)
		}
	}

	return mmGetOrderByID
}

// ExpectCtxParam1 sets up expected param ctx for Facade.GetOrderByID
func (mmGetOrderByID *mFacadeMockGetOrderByID) ExpectCtxParam1(ctx context.Context) *mFacadeMockGetOrderByID {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("FacadeMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &FacadeMockGetOrderByIDExpectation{}
	}

	if mmGetOrderByID.defaultExpectation.params != nil {
		mmGetOrderByID.mock.t.Fatalf("FacadeMock.GetOrderByID mock is already set by Expect")
	}

	if mmGetOrderByID.defaultExpectation.paramPtrs == nil {
		mmGetOrderByID.defaultExpectation.paramPtrs = &FacadeMockGetOrderByIDParamPtrs{}
	}
	mmGetOrderByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrderByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrderByID
}

// ExpectIdParam2 sets up expected param id for Facade.GetOrderByID
func (mmGetOrderByID *mFacadeMockGetOrderByID) ExpectIdParam2(id int) *mFacadeMockGetOrderByID {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("FacadeMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &FacadeMockGetOrderByIDExpectation{}
	}

	if mmGetOrderByID.defaultExpectation.params != nil {
		mmGetOrderByID.mock.t.Fatalf("FacadeMock.GetOrderByID mock is already set by Expect")
	}

	if mmGetOrderByID.defaultExpectation.paramPtrs == nil {
		mmGetOrderByID.defaultExpectation.paramPtrs = &FacadeMockGetOrderByIDParamPtrs{}
	}
	mmGetOrderByID.defaultExpectation.paramPtrs.id = &id
	mmGetOrderByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetOrderByID
}

// Inspect accepts an inspector function that has same arguments as the Facade.GetOrderByID
func (mmGetOrderByID *mFacadeMockGetOrderByID) Inspect(f func(ctx context.Context, id int)) *mFacadeMockGetOrderByID {
	if mmGetOrderByID.mock.inspectFuncGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("Inspect function is already set for FacadeMock.GetOrderByID")
	}

	mmGetOrderByID.mock.inspectFuncGetOrderByID = f

	return mmGetOrderByID
}

// Return sets up results that will be returned by Facade.GetOrderByID
func (mmGetOrderByID *mFacadeMockGetOrderByID) Return(op1 *dto.OrderDTO, err error) *FacadeMock {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("FacadeMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &FacadeMockGetOrderByIDExpectation{mock: mmGetOrderByID.mock}
	}
	mmGetOrderByID.defaultExpectation.results = &FacadeMockGetOrderByIDResults{op1, err}
	mmGetOrderByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrderByID.mock
}

// Set uses given function f to mock the Facade.GetOrderByID method
func (mmGetOrderByID *mFacadeMockGetOrderByID) Set(f func(ctx context.Context, id int) (op1 *dto.OrderDTO, err error)) *FacadeMock {
	if mmGetOrderByID.defaultExpectation != nil {
		mmGetOrderByID.mock.t.Fatalf("Default expectation is already set for the Facade.GetOrderByID method")
	}

	if len(mmGetOrderByID.expectations) > 0 {
		mmGetOrderByID.mock.t.Fatalf("Some expectations are already set for the Facade.GetOrderByID method")
	}

	mmGetOrderByID.mock.funcGetOrderByID = f
	mmGetOrderByID.mock.funcGetOrderByIDOrigin = minimock.CallerInfo(1)
	return mmGetOrderByID.mock
}

// When sets expectation for the Facade.GetOrderByID which will trigger the result defined by the following
// Then helper
func (mmGetOrderByID *mFacadeMockGetOrderByID) When(ctx context.Context, id int) *FacadeMockGetOrderByIDExpectation {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("FacadeMock.GetOrderByID mock is already set by Set")
	}

	expectation := &FacadeMockGetOrderByIDExpectation{
		mock:               mmGetOrderByID.mock,
		params:             &FacadeMockGetOrderByIDParams{ctx, id},
		expectationOrigins: FacadeMockGetOrderByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrderByID.expectations = append(mmGetOrderByID.expectations, expectation)
	return expectation
}

// Then sets up Facade.GetOrderByID return parameters for the expectation previously defined by the When method
func (e *FacadeMockGetOrderByIDExpectation) Then(op1 *dto.OrderDTO, err error) *FacadeMock {
	e.results = &FacadeMockGetOrderByIDResults{op1, err}
	return e.mock
}

// Times sets number of times Facade.GetOrderByID should be invoked
func (mmGetOrderByID *mFacadeMockGetOrderByID) Times(n uint64) *mFacadeMockGetOrderByID {
	if n == 0 {
		mmGetOrderByID.mock.t.Fatalf("Times of FacadeMock.GetOrderByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrderByID.expectedInvocations, n)
	mmGetOrderByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrderByID
}

func (mmGetOrderByID *mFacadeMockGetOrderByID) invocationsDone() bool {
	if len(mmGetOrderByID.expectations) == 0 && mmGetOrderByID.defaultExpectation == nil && mmGetOrderByID.mock.funcGetOrderByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrderByID.mock.afterGetOrderByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrderByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrderByID implements mm_usecase.Facade
func (mmGetOrderByID *FacadeMock) GetOrderByID(ctx context.Context, id int) (op1 *dto.OrderDTO, err error) {
	mm_atomic.AddUint64(&mmGetOrderByID.beforeGetOrderByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrderByID.afterGetOrderByIDCounter, 1)

	mmGetOrderByID.t.Helper()

	if mmGetOrderByID.inspectFuncGetOrderByID != nil {
		mmGetOrderByID.inspectFuncGetOrderByID(ctx, id)
	}

	mm_params := FacadeMockGetOrderByIDParams{ctx, id}

	// Record call args
	mmGetOrderByID.GetOrderByIDMock.mutex.Lock()
	mmGetOrderByID.GetOrderByIDMock.callArgs = append(mmGetOrderByID.GetOrderByIDMock.callArgs, &mm_params)
	mmGetOrderByID.GetOrderByIDMock.mutex.Unlock()

	for _, e := range mmGetOrderByID.GetOrderByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetOrderByID.GetOrderByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrderByID.GetOrderByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrderByID.GetOrderByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrderByID.GetOrderByIDMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockGetOrderByIDParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrderByID.t.Errorf("FacadeMock.GetOrderByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrderByID.GetOrderByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetOrderByID.t.Errorf("FacadeMock.GetOrderByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrderByID.GetOrderByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrderByID.t.Errorf("FacadeMock.GetOrderByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrderByID.GetOrderByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrderByID.GetOrderByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrderByID.t.Fatal("No results are set for the FacadeMock.GetOrderByID")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetOrderByID.funcGetOrderByID != nil {
		return mmGetOrderByID.funcGetOrderByID(ctx, id)
	}
	mmGetOrderByID.t.Fatalf("Unexpected call to FacadeMock.GetOrderByID. %v %v", ctx, id)
	return
}

// GetOrderByIDAfterCounter returns a count of finished FacadeMock.GetOrderByID invocations
func (mmGetOrderByID *FacadeMock) GetOrderByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderByID.afterGetOrderByIDCounter)
}

// GetOrderByIDBeforeCounter returns a count of FacadeMock.GetOrderByID invocations
func (mmGetOrderByID *FacadeMock) GetOrderByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderByID.beforeGetOrderByIDCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.GetOrderByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrderByID *mFacadeMockGetOrderByID) Calls() []*FacadeMockGetOrderByIDParams {
	mmGetOrderByID.mutex.RLock()

	argCopy := make([]*FacadeMockGetOrderByIDParams, len(mmGetOrderByID.callArgs))
	copy(argCopy, mmGetOrderByID.callArgs)

	mmGetOrderByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderByIDDone returns true if the count of the GetOrderByID invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockGetOrderByIDDone() bool {
	if m.GetOrderByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrderByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrderByIDMock.invocationsDone()
}

// MinimockGetOrderByIDInspect logs each unmet expectation
func (m *FacadeMock) MinimockGetOrderByIDInspect() {
	for _, e := range m.GetOrderByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.GetOrderByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrderByIDCounter := mm_atomic.LoadUint64(&m.afterGetOrderByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderByIDMock.defaultExpectation != nil && afterGetOrderByIDCounter < 1 {
		if m.GetOrderByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.GetOrderByID at\n%s", m.GetOrderByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.GetOrderByID at\n%s with params: %#v", m.GetOrderByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetOrderByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderByID != nil && afterGetOrderByIDCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.GetOrderByID at\n%s", m.funcGetOrderByIDOrigin)
	}

	if !m.GetOrderByIDMock.invocationsDone() && afterGetOrderByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.GetOrderByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrderByIDMock.expectedInvocations), m.GetOrderByIDMock.expectedInvocationsOrigin, afterGetOrderByIDCounter)
	}
}

type mFacadeMockGetOrdersByID struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockGetOrdersByIDExpectation
	expectations       []*FacadeMockGetOrdersByIDExpectation

	callArgs []*FacadeMockGetOrdersByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockGetOrdersByIDExpectation specifies expectation struct of the Facade.GetOrdersByID
type FacadeMockGetOrdersByIDExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockGetOrdersByIDParams
	paramPtrs          *FacadeMockGetOrdersByIDParamPtrs
	expectationOrigins FacadeMockGetOrdersByIDExpectationOrigins
	results            *FacadeMockGetOrdersByIDResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockGetOrdersByIDParams contains parameters of the Facade.GetOrdersByID
type FacadeMockGetOrdersByIDParams struct {
	ctx context.Context
	ids []int
}

// FacadeMockGetOrdersByIDParamPtrs contains pointers to parameters of the Facade.GetOrdersByID
type FacadeMockGetOrdersByIDParamPtrs struct {
	ctx *context.Context
	ids *[]int
}

// FacadeMockGetOrdersByIDResults contains results of the Facade.GetOrdersByID
type FacadeMockGetOrdersByIDResults struct {
	lp1 *dto.ListOrdersDTO
	err error
}

// FacadeMockGetOrdersByIDOrigins contains origins of expectations of the Facade.GetOrdersByID
type FacadeMockGetOrdersByIDExpectationOrigins struct {
	origin    string
	originCtx string
	originIds string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrdersByID *mFacadeMockGetOrdersByID) Optional() *mFacadeMockGetOrdersByID {
	mmGetOrdersByID.optional = true
	return mmGetOrdersByID
}

// Expect sets up expected params for Facade.GetOrdersByID
func (mmGetOrdersByID *mFacadeMockGetOrdersByID) Expect(ctx context.Context, ids []int) *mFacadeMockGetOrdersByID {
	if mmGetOrdersByID.mock.funcGetOrdersByID != nil {
		mmGetOrdersByID.mock.t.Fatalf("FacadeMock.GetOrdersByID mock is already set by Set")
	}

	if mmGetOrdersByID.defaultExpectation == nil {
		mmGetOrdersByID.defaultExpectation = &FacadeMockGetOrdersByIDExpectation{}
	}

	if mmGetOrdersByID.defaultExpectation.paramPtrs != nil {
		mmGetOrdersByID.mock.t.Fatalf("FacadeMock.GetOrdersByID mock is already set by ExpectParams functions")
	}

	mmGetOrdersByID.defaultExpectation.params = &FacadeMockGetOrdersByIDParams{ctx, ids}
	mmGetOrdersByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrdersByID.expectations {
		if minimock.Equal(e.params, mmGetOrdersByID.defaultExpectation.params) {
			mmGetOrdersByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrdersByID.defaultExpectation.params)
		}
	}

	return mmGetOrdersByID
}

// ExpectCtxParam1 sets up expected param ctx for Facade.GetOrdersByID
func (mmGetOrdersByID *mFacadeMockGetOrdersByID) ExpectCtxParam1(ctx context.Context) *mFacadeMockGetOrdersByID {
	if mmGetOrdersByID.mock.funcGetOrdersByID != nil {
		mmGetOrdersByID.mock.t.Fatalf("FacadeMock.GetOrdersByID mock is already set by Set")
	}

	if mmGetOrdersByID.defaultExpectation == nil {
		mmGetOrdersByID.defaultExpectation = &FacadeMockGetOrdersByIDExpectation{}
	}

	if mmGetOrdersByID.defaultExpectation.params != nil {
		mmGetOrdersByID.mock.t.Fatalf("FacadeMock.GetOrdersByID mock is already set by Expect")
	}

	if mmGetOrdersByID.defaultExpectation.paramPtrs == nil {
		mmGetOrdersByID.defaultExpectation.paramPtrs = &FacadeMockGetOrdersByIDParamPtrs{}
	}
	mmGetOrdersByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrdersByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrdersByID
}

// ExpectIdsParam2 sets up expected param ids for Facade.GetOrdersByID
func (mmGetOrdersByID *mFacadeMockGetOrdersByID) ExpectIdsParam2(ids []int) *mFacadeMockGetOrdersByID {
	if mmGetOrdersByID.mock.funcGetOrdersByID != nil {
		mmGetOrdersByID.mock.t.Fatalf("FacadeMock.GetOrdersByID mock is already set by Set")
	}

	if mmGetOrdersByID.defaultExpectation == nil {
		mmGetOrdersByID.defaultExpectation = &FacadeMockGetOrdersByIDExpectation{}
	}

	if mmGetOrdersByID.defaultExpectation.params != nil {
		mmGetOrdersByID.mock.t.Fatalf("FacadeMock.GetOrdersByID mock is already set by Expect")
	}

	if mmGetOrdersByID.defaultExpectation.paramPtrs == nil {
		mmGetOrdersByID.defaultExpectation.paramPtrs = &FacadeMockGetOrdersByIDParamPtrs{}
	}
	mmGetOrdersByID.defaultExpectation.paramPtrs.ids = &ids
	mmGetOrdersByID.defaultExpectation.expectationOrigins.originIds = minimock.CallerInfo(1)

	return mmGetOrdersByID
}

// Inspect accepts an inspector function that has same arguments as the Facade.GetOrdersByID
func (mmGetOrdersByID *mFacadeMockGetOrdersByID) Inspect(f func(ctx context.Context, ids []int)) *mFacadeMockGetOrdersByID {
	if mmGetOrdersByID.mock.inspectFuncGetOrdersByID != nil {
		mmGetOrdersByID.mock.t.Fatalf("Inspect function is already set for FacadeMock.GetOrdersByID")
	}

	mmGetOrdersByID.mock.inspectFuncGetOrdersByID = f

	return mmGetOrdersByID
}

// Return sets up results that will be returned by Facade.GetOrdersByID
func (mmGetOrdersByID *mFacadeMockGetOrdersByID) Return(lp1 *dto.ListOrdersDTO, err error) *FacadeMock {
	if mmGetOrdersByID.mock.funcGetOrdersByID != nil {
		mmGetOrdersByID.mock.t.Fatalf("FacadeMock.GetOrdersByID mock is already set by Set")
	}

	if mmGetOrdersByID.defaultExpectation == nil {
		mmGetOrdersByID.defaultExpectation = &FacadeMockGetOrdersByIDExpectation{mock: mmGetOrdersByID.mock}
	}
	mmGetOrdersByID.defaultExpectation.results = &FacadeMockGetOrdersByIDResults{lp1, err}
	mmGetOrdersByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrdersByID.mock
}

// Set uses given function f to mock the Facade.GetOrdersByID method
func (mmGetOrdersByID *mFacadeMockGetOrdersByID) Set(f func(ctx context.Context, ids []int) (lp1 *dto.ListOrdersDTO, err error)) *FacadeMock {
	if mmGetOrdersByID.defaultExpectation != nil {
		mmGetOrdersByID.mock.t.Fatalf("Default expectation is already set for the Facade.GetOrdersByID method")
	}

	if len(mmGetOrdersByID.expectations) > 0 {
		mmGetOrdersByID.mock.t.Fatalf("Some expectations are already set for the Facade.GetOrdersByID method")
	}

	mmGetOrdersByID.mock.funcGetOrdersByID = f
	mmGetOrdersByID.mock.funcGetOrdersByIDOrigin = minimock.CallerInfo(1)
	return mmGetOrdersByID.mock
}

// When sets expectation for the Facade.GetOrdersByID which will trigger the result defined by the following
// Then helper
func (mmGetOrdersByID *mFacadeMockGetOrdersByID) When(ctx context.Context, ids []int) *FacadeMockGetOrdersByIDExpectation {
	if mmGetOrdersByID.mock.funcGetOrdersByID != nil {
		mmGetOrdersByID.mock.t.Fatalf("FacadeMock.GetOrdersByID mock is already set by Set")
	}

	expectation := &FacadeMockGetOrdersByIDExpectation{
		mock:               mmGetOrdersByID.mock,
		params:             &FacadeMockGetOrdersByIDParams{ctx, ids},
		expectationOrigins: FacadeMockGetOrdersByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrdersByID.expectations = append(mmGetOrdersByID.expectations, expectation)
	return expectation
}

// Then sets up Facade.GetOrdersByID return parameters for the expectation previously defined by the When method
func (e *FacadeMockGetOrdersByIDExpectation) Then(lp1 *dto.ListOrdersDTO, err error) *FacadeMock {
	e.results = &FacadeMockGetOrdersByIDResults{lp1, err}
	return e.mock
}

// Times sets number of times Facade.GetOrdersByID should be invoked
func (mmGetOrdersByID *mFacadeMockGetOrdersByID) Times(n uint64) *mFacadeMockGetOrdersByID {
	if n == 0 {
		mmGetOrdersByID.mock.t.Fatalf("Times of FacadeMock.GetOrdersByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrdersByID.expectedInvocations, n)
	mmGetOrdersByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrdersByID
}

func (mmGetOrdersByID *mFacadeMockGetOrdersByID) invocationsDone() bool {
	if len(mmGetOrdersByID.expectations) == 0 && mmGetOrdersByID.defaultExpectation == nil && mmGetOrdersByID.mock.funcGetOrdersByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrdersByID.mock.afterGetOrdersByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrdersByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrdersByID implements mm_usecase.Facade
func (mmGetOrdersByID *FacadeMock) GetOrdersByID(ctx context.Context, ids []int) (lp1 *dto.ListOrdersDTO, err error) {
	mm_atomic.AddUint64(&mmGetOrdersByID.beforeGetOrdersByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrdersByID.afterGetOrdersByIDCounter, 1)

	mmGetOrdersByID.t.Helper()

	if mmGetOrdersByID.inspectFuncGetOrdersByID != nil {
		mmGetOrdersByID.inspectFuncGetOrdersByID(ctx, ids)
	}

	mm_params := FacadeMockGetOrdersByIDParams{ctx, ids}

	// Record call args
	mmGetOrdersByID.GetOrdersByIDMock.mutex.Lock()
	mmGetOrdersByID.GetOrdersByIDMock.callArgs = append(mmGetOrdersByID.GetOrdersByIDMock.callArgs, &mm_params)
	mmGetOrdersByID.GetOrdersByIDMock.mutex.Unlock()

	for _, e := range mmGetOrdersByID.GetOrdersByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmGetOrdersByID.GetOrdersByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrdersByID.GetOrdersByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrdersByID.GetOrdersByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrdersByID.GetOrdersByIDMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockGetOrdersByIDParams{ctx, ids}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrdersByID.t.Errorf("FacadeMock.GetOrdersByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrdersByID.GetOrdersByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ids != nil && !minimock.Equal(*mm_want_ptrs.ids, mm_got.ids) {
				mmGetOrdersByID.t.Errorf("FacadeMock.GetOrdersByID got unexpected parameter ids, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrdersByID.GetOrdersByIDMock.defaultExpectation.expectationOrigins.originIds, *mm_want_ptrs.ids, mm_got.ids, minimock.Diff(*mm_want_ptrs.ids, mm_got.ids))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrdersByID.t.Errorf("FacadeMock.GetOrdersByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrdersByID.GetOrdersByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrdersByID.GetOrdersByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrdersByID.t.Fatal("No results are set for the FacadeMock.GetOrdersByID")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmGetOrdersByID.funcGetOrdersByID != nil {
		return mmGetOrdersByID.funcGetOrdersByID(ctx, ids)
	}
	mmGetOrdersByID.t.Fatalf("Unexpected call to FacadeMock.GetOrdersByID. %v %v", ctx, ids)
	return
}

// GetOrdersByIDAfterCounter returns a count of finished FacadeMock.GetOrdersByID invocations
func (mmGetOrdersByID *FacadeMock) GetOrdersByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrdersByID.afterGetOrdersByIDCounter)
}

// GetOrdersByIDBeforeCounter returns a count of FacadeMock.GetOrdersByID invocations
func (mmGetOrdersByID *FacadeMock) GetOrdersByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrdersByID.beforeGetOrdersByIDCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.GetOrdersByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrdersByID *mFacadeMockGetOrdersByID) Calls() []*FacadeMockGetOrdersByIDParams {
	mmGetOrdersByID.mutex.RLock()

	argCopy := make([]*FacadeMockGetOrdersByIDParams, len(mmGetOrdersByID.callArgs))
	copy(argCopy, mmGetOrdersByID.callArgs)

	mmGetOrdersByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrdersByIDDone returns true if the count of the GetOrdersByID invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockGetOrdersByIDDone() bool {
	if m.GetOrdersByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrdersByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrdersByIDMock.invocationsDone()
}

// MinimockGetOrdersByIDInspect logs each unmet expectation
func (m *FacadeMock) MinimockGetOrdersByIDInspect() {
	for _, e := range m.GetOrdersByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.GetOrdersByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrdersByIDCounter := mm_atomic.LoadUint64(&m.afterGetOrdersByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrdersByIDMock.defaultExpectation != nil && afterGetOrdersByIDCounter < 1 {
		if m.GetOrdersByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.GetOrdersByID at\n%s", m.GetOrdersByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.GetOrdersByID at\n%s with params: %#v", m.GetOrdersByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetOrdersByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrdersByID != nil && afterGetOrdersByIDCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.GetOrdersByID at\n%s", m.funcGetOrdersByIDOrigin)
	}

	if !m.GetOrdersByIDMock.invocationsDone() && afterGetOrdersByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.GetOrdersByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrdersByIDMock.expectedInvocations), m.GetOrdersByIDMock.expectedInvocationsOrigin, afterGetOrdersByIDCounter)
	}
}

type mFacadeMockGetRefundsList struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockGetRefundsListExpectation
	expectations       []*FacadeMockGetRefundsListExpectation

	callArgs []*FacadeMockGetRefundsListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockGetRefundsListExpectation specifies expectation struct of the Facade.GetRefundsList
type FacadeMockGetRefundsListExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockGetRefundsListParams
	paramPtrs          *FacadeMockGetRefundsListParamPtrs
	expectationOrigins FacadeMockGetRefundsListExpectationOrigins
	results            *FacadeMockGetRefundsListResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockGetRefundsListParams contains parameters of the Facade.GetRefundsList
type FacadeMockGetRefundsListParams struct {
	ctx    context.Context
	limit  int
	offset int
}

// FacadeMockGetRefundsListParamPtrs contains pointers to parameters of the Facade.GetRefundsList
type FacadeMockGetRefundsListParamPtrs struct {
	ctx    *context.Context
	limit  *int
	offset *int
}

// FacadeMockGetRefundsListResults contains results of the Facade.GetRefundsList
type FacadeMockGetRefundsListResults struct {
	lp1 *dto.ListOrdersDTO
	err error
}

// FacadeMockGetRefundsListOrigins contains origins of expectations of the Facade.GetRefundsList
type FacadeMockGetRefundsListExpectationOrigins struct {
	origin       string
	originCtx    string
	originLimit  string
	originOffset string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRefundsList *mFacadeMockGetRefundsList) Optional() *mFacadeMockGetRefundsList {
	mmGetRefundsList.optional = true
	return mmGetRefundsList
}

// Expect sets up expected params for Facade.GetRefundsList
func (mmGetRefundsList *mFacadeMockGetRefundsList) Expect(ctx context.Context, limit int, offset int) *mFacadeMockGetRefundsList {
	if mmGetRefundsList.mock.funcGetRefundsList != nil {
		mmGetRefundsList.mock.t.Fatalf("FacadeMock.GetRefundsList mock is already set by Set")
	}

	if mmGetRefundsList.defaultExpectation == nil {
		mmGetRefundsList.defaultExpectation = &FacadeMockGetRefundsListExpectation{}
	}

	if mmGetRefundsList.defaultExpectation.paramPtrs != nil {
		mmGetRefundsList.mock.t.Fatalf("FacadeMock.GetRefundsList mock is already set by ExpectParams functions")
	}

	mmGetRefundsList.defaultExpectation.params = &FacadeMockGetRefundsListParams{ctx, limit, offset}
	mmGetRefundsList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetRefundsList.expectations {
		if minimock.Equal(e.params, mmGetRefundsList.defaultExpectation.params) {
			mmGetRefundsList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRefundsList.defaultExpectation.params)
		}
	}

	return mmGetRefundsList
}

// ExpectCtxParam1 sets up expected param ctx for Facade.GetRefundsList
func (mmGetRefundsList *mFacadeMockGetRefundsList) ExpectCtxParam1(ctx context.Context) *mFacadeMockGetRefundsList {
	if mmGetRefundsList.mock.funcGetRefundsList != nil {
		mmGetRefundsList.mock.t.Fatalf("FacadeMock.GetRefundsList mock is already set by Set")
	}

	if mmGetRefundsList.defaultExpectation == nil {
		mmGetRefundsList.defaultExpectation = &FacadeMockGetRefundsListExpectation{}
	}

	if mmGetRefundsList.defaultExpectation.params != nil {
		mmGetRefundsList.mock.t.Fatalf("FacadeMock.GetRefundsList mock is already set by Expect")
	}

	if mmGetRefundsList.defaultExpectation.paramPtrs == nil {
		mmGetRefundsList.defaultExpectation.paramPtrs = &FacadeMockGetRefundsListParamPtrs{}
	}
	mmGetRefundsList.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetRefundsList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetRefundsList
}

// ExpectLimitParam2 sets up expected param limit for Facade.GetRefundsList
func (mmGetRefundsList *mFacadeMockGetRefundsList) ExpectLimitParam2(limit int) *mFacadeMockGetRefundsList {
	if mmGetRefundsList.mock.funcGetRefundsList != nil {
		mmGetRefundsList.mock.t.Fatalf("FacadeMock.GetRefundsList mock is already set by Set")
	}

	if mmGetRefundsList.defaultExpectation == nil {
		mmGetRefundsList.defaultExpectation = &FacadeMockGetRefundsListExpectation{}
	}

	if mmGetRefundsList.defaultExpectation.params != nil {
		mmGetRefundsList.mock.t.Fatalf("FacadeMock.GetRefundsList mock is already set by Expect")
	}

	if mmGetRefundsList.defaultExpectation.paramPtrs == nil {
		mmGetRefundsList.defaultExpectation.paramPtrs = &FacadeMockGetRefundsListParamPtrs{}
	}
	mmGetRefundsList.defaultExpectation.paramPtrs.limit = &limit
	mmGetRefundsList.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmGetRefundsList
}

// ExpectOffsetParam3 sets up expected param offset for Facade.GetRefundsList
func (mmGetRefundsList *mFacadeMockGetRefundsList) ExpectOffsetParam3(offset int) *mFacadeMockGetRefundsList {
	if mmGetRefundsList.mock.funcGetRefundsList != nil {
		mmGetRefundsList.mock.t.Fatalf("FacadeMock.GetRefundsList mock is already set by Set")
	}

	if mmGetRefundsList.defaultExpectation == nil {
		mmGetRefundsList.defaultExpectation = &FacadeMockGetRefundsListExpectation{}
	}

	if mmGetRefundsList.defaultExpectation.params != nil {
		mmGetRefundsList.mock.t.Fatalf("FacadeMock.GetRefundsList mock is already set by Expect")
	}

	if mmGetRefundsList.defaultExpectation.paramPtrs == nil {
		mmGetRefundsList.defaultExpectation.paramPtrs = &FacadeMockGetRefundsListParamPtrs{}
	}
	mmGetRefundsList.defaultExpectation.paramPtrs.offset = &offset
	mmGetRefundsList.defaultExpectation.expectationOrigins.originOffset = minimock.CallerInfo(1)

	return mmGetRefundsList
}

// Inspect accepts an inspector function that has same arguments as the Facade.GetRefundsList
func (mmGetRefundsList *mFacadeMockGetRefundsList) Inspect(f func(ctx context.Context, limit int, offset int)) *mFacadeMockGetRefundsList {
	if mmGetRefundsList.mock.inspectFuncGetRefundsList != nil {
		mmGetRefundsList.mock.t.Fatalf("Inspect function is already set for FacadeMock.GetRefundsList")
	}

	mmGetRefundsList.mock.inspectFuncGetRefundsList = f

	return mmGetRefundsList
}

// Return sets up results that will be returned by Facade.GetRefundsList
func (mmGetRefundsList *mFacadeMockGetRefundsList) Return(lp1 *dto.ListOrdersDTO, err error) *FacadeMock {
	if mmGetRefundsList.mock.funcGetRefundsList != nil {
		mmGetRefundsList.mock.t.Fatalf("FacadeMock.GetRefundsList mock is already set by Set")
	}

	if mmGetRefundsList.defaultExpectation == nil {
		mmGetRefundsList.defaultExpectation = &FacadeMockGetRefundsListExpectation{mock: mmGetRefundsList.mock}
	}
	mmGetRefundsList.defaultExpectation.results = &FacadeMockGetRefundsListResults{lp1, err}
	mmGetRefundsList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetRefundsList.mock
}

// Set uses given function f to mock the Facade.GetRefundsList method
func (mmGetRefundsList *mFacadeMockGetRefundsList) Set(f func(ctx context.Context, limit int, offset int) (lp1 *dto.ListOrdersDTO, err error)) *FacadeMock {
	if mmGetRefundsList.defaultExpectation != nil {
		mmGetRefundsList.mock.t.Fatalf("Default expectation is already set for the Facade.GetRefundsList method")
	}

	if len(mmGetRefundsList.expectations) > 0 {
		mmGetRefundsList.mock.t.Fatalf("Some expectations are already set for the Facade.GetRefundsList method")
	}

	mmGetRefundsList.mock.funcGetRefundsList = f
	mmGetRefundsList.mock.funcGetRefundsListOrigin = minimock.CallerInfo(1)
	return mmGetRefundsList.mock
}

// When sets expectation for the Facade.GetRefundsList which will trigger the result defined by the following
// Then helper
func (mmGetRefundsList *mFacadeMockGetRefundsList) When(ctx context.Context, limit int, offset int) *FacadeMockGetRefundsListExpectation {
	if mmGetRefundsList.mock.funcGetRefundsList != nil {
		mmGetRefundsList.mock.t.Fatalf("FacadeMock.GetRefundsList mock is already set by Set")
	}

	expectation := &FacadeMockGetRefundsListExpectation{
		mock:               mmGetRefundsList.mock,
		params:             &FacadeMockGetRefundsListParams{ctx, limit, offset},
		expectationOrigins: FacadeMockGetRefundsListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetRefundsList.expectations = append(mmGetRefundsList.expectations, expectation)
	return expectation
}

// Then sets up Facade.GetRefundsList return parameters for the expectation previously defined by the When method
func (e *FacadeMockGetRefundsListExpectation) Then(lp1 *dto.ListOrdersDTO, err error) *FacadeMock {
	e.results = &FacadeMockGetRefundsListResults{lp1, err}
	return e.mock
}

// Times sets number of times Facade.GetRefundsList should be invoked
func (mmGetRefundsList *mFacadeMockGetRefundsList) Times(n uint64) *mFacadeMockGetRefundsList {
	if n == 0 {
		mmGetRefundsList.mock.t.Fatalf("Times of FacadeMock.GetRefundsList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRefundsList.expectedInvocations, n)
	mmGetRefundsList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetRefundsList
}

func (mmGetRefundsList *mFacadeMockGetRefundsList) invocationsDone() bool {
	if len(mmGetRefundsList.expectations) == 0 && mmGetRefundsList.defaultExpectation == nil && mmGetRefundsList.mock.funcGetRefundsList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRefundsList.mock.afterGetRefundsListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRefundsList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRefundsList implements mm_usecase.Facade
func (mmGetRefundsList *FacadeMock) GetRefundsList(ctx context.Context, limit int, offset int) (lp1 *dto.ListOrdersDTO, err error) {
	mm_atomic.AddUint64(&mmGetRefundsList.beforeGetRefundsListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRefundsList.afterGetRefundsListCounter, 1)

	mmGetRefundsList.t.Helper()

	if mmGetRefundsList.inspectFuncGetRefundsList != nil {
		mmGetRefundsList.inspectFuncGetRefundsList(ctx, limit, offset)
	}

	mm_params := FacadeMockGetRefundsListParams{ctx, limit, offset}

	// Record call args
	mmGetRefundsList.GetRefundsListMock.mutex.Lock()
	mmGetRefundsList.GetRefundsListMock.callArgs = append(mmGetRefundsList.GetRefundsListMock.callArgs, &mm_params)
	mmGetRefundsList.GetRefundsListMock.mutex.Unlock()

	for _, e := range mmGetRefundsList.GetRefundsListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmGetRefundsList.GetRefundsListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRefundsList.GetRefundsListMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRefundsList.GetRefundsListMock.defaultExpectation.params
		mm_want_ptrs := mmGetRefundsList.GetRefundsListMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockGetRefundsListParams{ctx, limit, offset}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetRefundsList.t.Errorf("FacadeMock.GetRefundsList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRefundsList.GetRefundsListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetRefundsList.t.Errorf("FacadeMock.GetRefundsList got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRefundsList.GetRefundsListMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

			if mm_want_ptrs.offset != nil && !minimock.Equal(*mm_want_ptrs.offset, mm_got.offset) {
				mmGetRefundsList.t.Errorf("FacadeMock.GetRefundsList got unexpected parameter offset, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRefundsList.GetRefundsListMock.defaultExpectation.expectationOrigins.originOffset, *mm_want_ptrs.offset, mm_got.offset, minimock.Diff(*mm_want_ptrs.offset, mm_got.offset))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRefundsList.t.Errorf("FacadeMock.GetRefundsList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetRefundsList.GetRefundsListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRefundsList.GetRefundsListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRefundsList.t.Fatal("No results are set for the FacadeMock.GetRefundsList")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmGetRefundsList.funcGetRefundsList != nil {
		return mmGetRefundsList.funcGetRefundsList(ctx, limit, offset)
	}
	mmGetRefundsList.t.Fatalf("Unexpected call to FacadeMock.GetRefundsList. %v %v %v", ctx, limit, offset)
	return
}

// GetRefundsListAfterCounter returns a count of finished FacadeMock.GetRefundsList invocations
func (mmGetRefundsList *FacadeMock) GetRefundsListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefundsList.afterGetRefundsListCounter)
}

// GetRefundsListBeforeCounter returns a count of FacadeMock.GetRefundsList invocations
func (mmGetRefundsList *FacadeMock) GetRefundsListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefundsList.beforeGetRefundsListCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.GetRefundsList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRefundsList *mFacadeMockGetRefundsList) Calls() []*FacadeMockGetRefundsListParams {
	mmGetRefundsList.mutex.RLock()

	argCopy := make([]*FacadeMockGetRefundsListParams, len(mmGetRefundsList.callArgs))
	copy(argCopy, mmGetRefundsList.callArgs)

	mmGetRefundsList.mutex.RUnlock()

	return argCopy
}

// MinimockGetRefundsListDone returns true if the count of the GetRefundsList invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockGetRefundsListDone() bool {
	if m.GetRefundsListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRefundsListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRefundsListMock.invocationsDone()
}

// MinimockGetRefundsListInspect logs each unmet expectation
func (m *FacadeMock) MinimockGetRefundsListInspect() {
	for _, e := range m.GetRefundsListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.GetRefundsList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetRefundsListCounter := mm_atomic.LoadUint64(&m.afterGetRefundsListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRefundsListMock.defaultExpectation != nil && afterGetRefundsListCounter < 1 {
		if m.GetRefundsListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.GetRefundsList at\n%s", m.GetRefundsListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.GetRefundsList at\n%s with params: %#v", m.GetRefundsListMock.defaultExpectation.expectationOrigins.origin, *m.GetRefundsListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRefundsList != nil && afterGetRefundsListCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.GetRefundsList at\n%s", m.funcGetRefundsListOrigin)
	}

	if !m.GetRefundsListMock.invocationsDone() && afterGetRefundsListCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.GetRefundsList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetRefundsListMock.expectedInvocations), m.GetRefundsListMock.expectedInvocationsOrigin, afterGetRefundsListCounter)
	}
}

type mFacadeMockUpdateOrder struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockUpdateOrderExpectation
	expectations       []*FacadeMockUpdateOrderExpectation

	callArgs []*FacadeMockUpdateOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockUpdateOrderExpectation specifies expectation struct of the Facade.UpdateOrder
type FacadeMockUpdateOrderExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockUpdateOrderParams
	paramPtrs          *FacadeMockUpdateOrderParamPtrs
	expectationOrigins FacadeMockUpdateOrderExpectationOrigins
	results            *FacadeMockUpdateOrderResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockUpdateOrderParams contains parameters of the Facade.UpdateOrder
type FacadeMockUpdateOrderParams struct {
	ctx      context.Context
	orderDTO dto.OrderDTO
}

// FacadeMockUpdateOrderParamPtrs contains pointers to parameters of the Facade.UpdateOrder
type FacadeMockUpdateOrderParamPtrs struct {
	ctx      *context.Context
	orderDTO *dto.OrderDTO
}

// FacadeMockUpdateOrderResults contains results of the Facade.UpdateOrder
type FacadeMockUpdateOrderResults struct {
	err error
}

// FacadeMockUpdateOrderOrigins contains origins of expectations of the Facade.UpdateOrder
type FacadeMockUpdateOrderExpectationOrigins struct {
	origin         string
	originCtx      string
	originOrderDTO string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateOrder *mFacadeMockUpdateOrder) Optional() *mFacadeMockUpdateOrder {
	mmUpdateOrder.optional = true
	return mmUpdateOrder
}

// Expect sets up expected params for Facade.UpdateOrder
func (mmUpdateOrder *mFacadeMockUpdateOrder) Expect(ctx context.Context, orderDTO dto.OrderDTO) *mFacadeMockUpdateOrder {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("FacadeMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &FacadeMockUpdateOrderExpectation{}
	}

	if mmUpdateOrder.defaultExpectation.paramPtrs != nil {
		mmUpdateOrder.mock.t.Fatalf("FacadeMock.UpdateOrder mock is already set by ExpectParams functions")
	}

	mmUpdateOrder.defaultExpectation.params = &FacadeMockUpdateOrderParams{ctx, orderDTO}
	mmUpdateOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateOrder.expectations {
		if minimock.Equal(e.params, mmUpdateOrder.defaultExpectation.params) {
			mmUpdateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrder.defaultExpectation.params)
		}
	}

	return mmUpdateOrder
}

// ExpectCtxParam1 sets up expected param ctx for Facade.UpdateOrder
func (mmUpdateOrder *mFacadeMockUpdateOrder) ExpectCtxParam1(ctx context.Context) *mFacadeMockUpdateOrder {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("FacadeMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &FacadeMockUpdateOrderExpectation{}
	}

	if mmUpdateOrder.defaultExpectation.params != nil {
		mmUpdateOrder.mock.t.Fatalf("FacadeMock.UpdateOrder mock is already set by Expect")
	}

	if mmUpdateOrder.defaultExpectation.paramPtrs == nil {
		mmUpdateOrder.defaultExpectation.paramPtrs = &FacadeMockUpdateOrderParamPtrs{}
	}
	mmUpdateOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateOrder
}

// ExpectOrderDTOParam2 sets up expected param orderDTO for Facade.UpdateOrder
func (mmUpdateOrder *mFacadeMockUpdateOrder) ExpectOrderDTOParam2(orderDTO dto.OrderDTO) *mFacadeMockUpdateOrder {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("FacadeMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &FacadeMockUpdateOrderExpectation{}
	}

	if mmUpdateOrder.defaultExpectation.params != nil {
		mmUpdateOrder.mock.t.Fatalf("FacadeMock.UpdateOrder mock is already set by Expect")
	}

	if mmUpdateOrder.defaultExpectation.paramPtrs == nil {
		mmUpdateOrder.defaultExpectation.paramPtrs = &FacadeMockUpdateOrderParamPtrs{}
	}
	mmUpdateOrder.defaultExpectation.paramPtrs.orderDTO = &orderDTO
	mmUpdateOrder.defaultExpectation.expectationOrigins.originOrderDTO = minimock.CallerInfo(1)

	return mmUpdateOrder
}

// Inspect accepts an inspector function that has same arguments as the Facade.UpdateOrder
func (mmUpdateOrder *mFacadeMockUpdateOrder) Inspect(f func(ctx context.Context, orderDTO dto.OrderDTO)) *mFacadeMockUpdateOrder {
	if mmUpdateOrder.mock.inspectFuncUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("Inspect function is already set for FacadeMock.UpdateOrder")
	}

	mmUpdateOrder.mock.inspectFuncUpdateOrder = f

	return mmUpdateOrder
}

// Return sets up results that will be returned by Facade.UpdateOrder
func (mmUpdateOrder *mFacadeMockUpdateOrder) Return(err error) *FacadeMock {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("FacadeMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &FacadeMockUpdateOrderExpectation{mock: mmUpdateOrder.mock}
	}
	mmUpdateOrder.defaultExpectation.results = &FacadeMockUpdateOrderResults{err}
	mmUpdateOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateOrder.mock
}

// Set uses given function f to mock the Facade.UpdateOrder method
func (mmUpdateOrder *mFacadeMockUpdateOrder) Set(f func(ctx context.Context, orderDTO dto.OrderDTO) (err error)) *FacadeMock {
	if mmUpdateOrder.defaultExpectation != nil {
		mmUpdateOrder.mock.t.Fatalf("Default expectation is already set for the Facade.UpdateOrder method")
	}

	if len(mmUpdateOrder.expectations) > 0 {
		mmUpdateOrder.mock.t.Fatalf("Some expectations are already set for the Facade.UpdateOrder method")
	}

	mmUpdateOrder.mock.funcUpdateOrder = f
	mmUpdateOrder.mock.funcUpdateOrderOrigin = minimock.CallerInfo(1)
	return mmUpdateOrder.mock
}

// When sets expectation for the Facade.UpdateOrder which will trigger the result defined by the following
// Then helper
func (mmUpdateOrder *mFacadeMockUpdateOrder) When(ctx context.Context, orderDTO dto.OrderDTO) *FacadeMockUpdateOrderExpectation {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("FacadeMock.UpdateOrder mock is already set by Set")
	}

	expectation := &FacadeMockUpdateOrderExpectation{
		mock:               mmUpdateOrder.mock,
		params:             &FacadeMockUpdateOrderParams{ctx, orderDTO},
		expectationOrigins: FacadeMockUpdateOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateOrder.expectations = append(mmUpdateOrder.expectations, expectation)
	return expectation
}

// Then sets up Facade.UpdateOrder return parameters for the expectation previously defined by the When method
func (e *FacadeMockUpdateOrderExpectation) Then(err error) *FacadeMock {
	e.results = &FacadeMockUpdateOrderResults{err}
	return e.mock
}

// Times sets number of times Facade.UpdateOrder should be invoked
func (mmUpdateOrder *mFacadeMockUpdateOrder) Times(n uint64) *mFacadeMockUpdateOrder {
	if n == 0 {
		mmUpdateOrder.mock.t.Fatalf("Times of FacadeMock.UpdateOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateOrder.expectedInvocations, n)
	mmUpdateOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateOrder
}

func (mmUpdateOrder *mFacadeMockUpdateOrder) invocationsDone() bool {
	if len(mmUpdateOrder.expectations) == 0 && mmUpdateOrder.defaultExpectation == nil && mmUpdateOrder.mock.funcUpdateOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateOrder.mock.afterUpdateOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateOrder implements mm_usecase.Facade
func (mmUpdateOrder *FacadeMock) UpdateOrder(ctx context.Context, orderDTO dto.OrderDTO) (err error) {
	mm_atomic.AddUint64(&mmUpdateOrder.beforeUpdateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrder.afterUpdateOrderCounter, 1)

	mmUpdateOrder.t.Helper()

	if mmUpdateOrder.inspectFuncUpdateOrder != nil {
		mmUpdateOrder.inspectFuncUpdateOrder(ctx, orderDTO)
	}

	mm_params := FacadeMockUpdateOrderParams{ctx, orderDTO}

	// Record call args
	mmUpdateOrder.UpdateOrderMock.mutex.Lock()
	mmUpdateOrder.UpdateOrderMock.callArgs = append(mmUpdateOrder.UpdateOrderMock.callArgs, &mm_params)
	mmUpdateOrder.UpdateOrderMock.mutex.Unlock()

	for _, e := range mmUpdateOrder.UpdateOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateOrder.UpdateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrder.UpdateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrder.UpdateOrderMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateOrder.UpdateOrderMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockUpdateOrderParams{ctx, orderDTO}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateOrder.t.Errorf("FacadeMock.UpdateOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateOrder.UpdateOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderDTO != nil && !minimock.Equal(*mm_want_ptrs.orderDTO, mm_got.orderDTO) {
				mmUpdateOrder.t.Errorf("FacadeMock.UpdateOrder got unexpected parameter orderDTO, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateOrder.UpdateOrderMock.defaultExpectation.expectationOrigins.originOrderDTO, *mm_want_ptrs.orderDTO, mm_got.orderDTO, minimock.Diff(*mm_want_ptrs.orderDTO, mm_got.orderDTO))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrder.t.Errorf("FacadeMock.UpdateOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateOrder.UpdateOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrder.UpdateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrder.t.Fatal("No results are set for the FacadeMock.UpdateOrder")
		}
		return (*mm_results).err
	}
	if mmUpdateOrder.funcUpdateOrder != nil {
		return mmUpdateOrder.funcUpdateOrder(ctx, orderDTO)
	}
	mmUpdateOrder.t.Fatalf("Unexpected call to FacadeMock.UpdateOrder. %v %v", ctx, orderDTO)
	return
}

// UpdateOrderAfterCounter returns a count of finished FacadeMock.UpdateOrder invocations
func (mmUpdateOrder *FacadeMock) UpdateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrder.afterUpdateOrderCounter)
}

// UpdateOrderBeforeCounter returns a count of FacadeMock.UpdateOrder invocations
func (mmUpdateOrder *FacadeMock) UpdateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrder.beforeUpdateOrderCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.UpdateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrder *mFacadeMockUpdateOrder) Calls() []*FacadeMockUpdateOrderParams {
	mmUpdateOrder.mutex.RLock()

	argCopy := make([]*FacadeMockUpdateOrderParams, len(mmUpdateOrder.callArgs))
	copy(argCopy, mmUpdateOrder.callArgs)

	mmUpdateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrderDone returns true if the count of the UpdateOrder invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockUpdateOrderDone() bool {
	if m.UpdateOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateOrderMock.invocationsDone()
}

// MinimockUpdateOrderInspect logs each unmet expectation
func (m *FacadeMock) MinimockUpdateOrderInspect() {
	for _, e := range m.UpdateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.UpdateOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateOrderCounter := mm_atomic.LoadUint64(&m.afterUpdateOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderMock.defaultExpectation != nil && afterUpdateOrderCounter < 1 {
		if m.UpdateOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.UpdateOrder at\n%s", m.UpdateOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.UpdateOrder at\n%s with params: %#v", m.UpdateOrderMock.defaultExpectation.expectationOrigins.origin, *m.UpdateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrder != nil && afterUpdateOrderCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.UpdateOrder at\n%s", m.funcUpdateOrderOrigin)
	}

	if !m.UpdateOrderMock.invocationsDone() && afterUpdateOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.UpdateOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateOrderMock.expectedInvocations), m.UpdateOrderMock.expectedInvocationsOrigin, afterUpdateOrderCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FacadeMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddOrderInspect()

			m.MinimockGetClientOrdersListInspect()

			m.MinimockGetOrderByIDInspect()

			m.MinimockGetOrdersByIDInspect()

			m.MinimockGetRefundsListInspect()

			m.MinimockUpdateOrderInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FacadeMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FacadeMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddOrderDone() &&
		m.MinimockGetClientOrdersListDone() &&
		m.MinimockGetOrderByIDDone() &&
		m.MinimockGetOrdersByIDDone() &&
		m.MinimockGetRefundsListDone() &&
		m.MinimockUpdateOrderDone()
}
