// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/Na322Pr/route256/internal/usecase.OrderRepoFacade -o order_repo_facade_mock.go -n OrderRepoFacadeMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/Na322Pr/route256/internal/dto"
)

// OrderRepoFacadeMock implements mm_usecase.OrderRepoFacade
type OrderRepoFacadeMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddOrder          func(ctx context.Context, orderDTO dto.OrderDTO) (err error)
	funcAddOrderOrigin    string
	inspectFuncAddOrder   func(ctx context.Context, orderDTO dto.OrderDTO)
	afterAddOrderCounter  uint64
	beforeAddOrderCounter uint64
	AddOrderMock          mOrderRepoFacadeMockAddOrder

	funcGetClientOrdersList          func(ctx context.Context, clientID int) (lp1 *dto.ListOrdersDTO, err error)
	funcGetClientOrdersListOrigin    string
	inspectFuncGetClientOrdersList   func(ctx context.Context, clientID int)
	afterGetClientOrdersListCounter  uint64
	beforeGetClientOrdersListCounter uint64
	GetClientOrdersListMock          mOrderRepoFacadeMockGetClientOrdersList

	funcGetOrderByID          func(ctx context.Context, id int64) (op1 *dto.OrderDTO, err error)
	funcGetOrderByIDOrigin    string
	inspectFuncGetOrderByID   func(ctx context.Context, id int64)
	afterGetOrderByIDCounter  uint64
	beforeGetOrderByIDCounter uint64
	GetOrderByIDMock          mOrderRepoFacadeMockGetOrderByID

	funcGetOrdersByIDs          func(ctx context.Context, ids []int64) (lp1 *dto.ListOrdersDTO, err error)
	funcGetOrdersByIDsOrigin    string
	inspectFuncGetOrdersByIDs   func(ctx context.Context, ids []int64)
	afterGetOrdersByIDsCounter  uint64
	beforeGetOrdersByIDsCounter uint64
	GetOrdersByIDsMock          mOrderRepoFacadeMockGetOrdersByIDs

	funcGetRefundsList          func(ctx context.Context, limit int, offset int) (lp1 *dto.ListOrdersDTO, err error)
	funcGetRefundsListOrigin    string
	inspectFuncGetRefundsList   func(ctx context.Context, limit int, offset int)
	afterGetRefundsListCounter  uint64
	beforeGetRefundsListCounter uint64
	GetRefundsListMock          mOrderRepoFacadeMockGetRefundsList

	funcUpdateOrder          func(ctx context.Context, orderDTO dto.OrderDTO) (err error)
	funcUpdateOrderOrigin    string
	inspectFuncUpdateOrder   func(ctx context.Context, orderDTO dto.OrderDTO)
	afterUpdateOrderCounter  uint64
	beforeUpdateOrderCounter uint64
	UpdateOrderMock          mOrderRepoFacadeMockUpdateOrder
}

// NewOrderRepoFacadeMock returns a mock for mm_usecase.OrderRepoFacade
func NewOrderRepoFacadeMock(t minimock.Tester) *OrderRepoFacadeMock {
	m := &OrderRepoFacadeMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddOrderMock = mOrderRepoFacadeMockAddOrder{mock: m}
	m.AddOrderMock.callArgs = []*OrderRepoFacadeMockAddOrderParams{}

	m.GetClientOrdersListMock = mOrderRepoFacadeMockGetClientOrdersList{mock: m}
	m.GetClientOrdersListMock.callArgs = []*OrderRepoFacadeMockGetClientOrdersListParams{}

	m.GetOrderByIDMock = mOrderRepoFacadeMockGetOrderByID{mock: m}
	m.GetOrderByIDMock.callArgs = []*OrderRepoFacadeMockGetOrderByIDParams{}

	m.GetOrdersByIDsMock = mOrderRepoFacadeMockGetOrdersByIDs{mock: m}
	m.GetOrdersByIDsMock.callArgs = []*OrderRepoFacadeMockGetOrdersByIDsParams{}

	m.GetRefundsListMock = mOrderRepoFacadeMockGetRefundsList{mock: m}
	m.GetRefundsListMock.callArgs = []*OrderRepoFacadeMockGetRefundsListParams{}

	m.UpdateOrderMock = mOrderRepoFacadeMockUpdateOrder{mock: m}
	m.UpdateOrderMock.callArgs = []*OrderRepoFacadeMockUpdateOrderParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderRepoFacadeMockAddOrder struct {
	optional           bool
	mock               *OrderRepoFacadeMock
	defaultExpectation *OrderRepoFacadeMockAddOrderExpectation
	expectations       []*OrderRepoFacadeMockAddOrderExpectation

	callArgs []*OrderRepoFacadeMockAddOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepoFacadeMockAddOrderExpectation specifies expectation struct of the OrderRepoFacade.AddOrder
type OrderRepoFacadeMockAddOrderExpectation struct {
	mock               *OrderRepoFacadeMock
	params             *OrderRepoFacadeMockAddOrderParams
	paramPtrs          *OrderRepoFacadeMockAddOrderParamPtrs
	expectationOrigins OrderRepoFacadeMockAddOrderExpectationOrigins
	results            *OrderRepoFacadeMockAddOrderResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepoFacadeMockAddOrderParams contains parameters of the OrderRepoFacade.AddOrder
type OrderRepoFacadeMockAddOrderParams struct {
	ctx      context.Context
	orderDTO dto.OrderDTO
}

// OrderRepoFacadeMockAddOrderParamPtrs contains pointers to parameters of the OrderRepoFacade.AddOrder
type OrderRepoFacadeMockAddOrderParamPtrs struct {
	ctx      *context.Context
	orderDTO *dto.OrderDTO
}

// OrderRepoFacadeMockAddOrderResults contains results of the OrderRepoFacade.AddOrder
type OrderRepoFacadeMockAddOrderResults struct {
	err error
}

// OrderRepoFacadeMockAddOrderOrigins contains origins of expectations of the OrderRepoFacade.AddOrder
type OrderRepoFacadeMockAddOrderExpectationOrigins struct {
	origin         string
	originCtx      string
	originOrderDTO string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddOrder *mOrderRepoFacadeMockAddOrder) Optional() *mOrderRepoFacadeMockAddOrder {
	mmAddOrder.optional = true
	return mmAddOrder
}

// Expect sets up expected params for OrderRepoFacade.AddOrder
func (mmAddOrder *mOrderRepoFacadeMockAddOrder) Expect(ctx context.Context, orderDTO dto.OrderDTO) *mOrderRepoFacadeMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepoFacadeMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &OrderRepoFacadeMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.paramPtrs != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepoFacadeMock.AddOrder mock is already set by ExpectParams functions")
	}

	mmAddOrder.defaultExpectation.params = &OrderRepoFacadeMockAddOrderParams{ctx, orderDTO}
	mmAddOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddOrder.expectations {
		if minimock.Equal(e.params, mmAddOrder.defaultExpectation.params) {
			mmAddOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddOrder.defaultExpectation.params)
		}
	}

	return mmAddOrder
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepoFacade.AddOrder
func (mmAddOrder *mOrderRepoFacadeMockAddOrder) ExpectCtxParam1(ctx context.Context) *mOrderRepoFacadeMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepoFacadeMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &OrderRepoFacadeMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepoFacadeMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &OrderRepoFacadeMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddOrder
}

// ExpectOrderDTOParam2 sets up expected param orderDTO for OrderRepoFacade.AddOrder
func (mmAddOrder *mOrderRepoFacadeMockAddOrder) ExpectOrderDTOParam2(orderDTO dto.OrderDTO) *mOrderRepoFacadeMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepoFacadeMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &OrderRepoFacadeMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepoFacadeMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &OrderRepoFacadeMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.orderDTO = &orderDTO
	mmAddOrder.defaultExpectation.expectationOrigins.originOrderDTO = minimock.CallerInfo(1)

	return mmAddOrder
}

// Inspect accepts an inspector function that has same arguments as the OrderRepoFacade.AddOrder
func (mmAddOrder *mOrderRepoFacadeMockAddOrder) Inspect(f func(ctx context.Context, orderDTO dto.OrderDTO)) *mOrderRepoFacadeMockAddOrder {
	if mmAddOrder.mock.inspectFuncAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("Inspect function is already set for OrderRepoFacadeMock.AddOrder")
	}

	mmAddOrder.mock.inspectFuncAddOrder = f

	return mmAddOrder
}

// Return sets up results that will be returned by OrderRepoFacade.AddOrder
func (mmAddOrder *mOrderRepoFacadeMockAddOrder) Return(err error) *OrderRepoFacadeMock {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepoFacadeMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &OrderRepoFacadeMockAddOrderExpectation{mock: mmAddOrder.mock}
	}
	mmAddOrder.defaultExpectation.results = &OrderRepoFacadeMockAddOrderResults{err}
	mmAddOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddOrder.mock
}

// Set uses given function f to mock the OrderRepoFacade.AddOrder method
func (mmAddOrder *mOrderRepoFacadeMockAddOrder) Set(f func(ctx context.Context, orderDTO dto.OrderDTO) (err error)) *OrderRepoFacadeMock {
	if mmAddOrder.defaultExpectation != nil {
		mmAddOrder.mock.t.Fatalf("Default expectation is already set for the OrderRepoFacade.AddOrder method")
	}

	if len(mmAddOrder.expectations) > 0 {
		mmAddOrder.mock.t.Fatalf("Some expectations are already set for the OrderRepoFacade.AddOrder method")
	}

	mmAddOrder.mock.funcAddOrder = f
	mmAddOrder.mock.funcAddOrderOrigin = minimock.CallerInfo(1)
	return mmAddOrder.mock
}

// When sets expectation for the OrderRepoFacade.AddOrder which will trigger the result defined by the following
// Then helper
func (mmAddOrder *mOrderRepoFacadeMockAddOrder) When(ctx context.Context, orderDTO dto.OrderDTO) *OrderRepoFacadeMockAddOrderExpectation {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("OrderRepoFacadeMock.AddOrder mock is already set by Set")
	}

	expectation := &OrderRepoFacadeMockAddOrderExpectation{
		mock:               mmAddOrder.mock,
		params:             &OrderRepoFacadeMockAddOrderParams{ctx, orderDTO},
		expectationOrigins: OrderRepoFacadeMockAddOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddOrder.expectations = append(mmAddOrder.expectations, expectation)
	return expectation
}

// Then sets up OrderRepoFacade.AddOrder return parameters for the expectation previously defined by the When method
func (e *OrderRepoFacadeMockAddOrderExpectation) Then(err error) *OrderRepoFacadeMock {
	e.results = &OrderRepoFacadeMockAddOrderResults{err}
	return e.mock
}

// Times sets number of times OrderRepoFacade.AddOrder should be invoked
func (mmAddOrder *mOrderRepoFacadeMockAddOrder) Times(n uint64) *mOrderRepoFacadeMockAddOrder {
	if n == 0 {
		mmAddOrder.mock.t.Fatalf("Times of OrderRepoFacadeMock.AddOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddOrder.expectedInvocations, n)
	mmAddOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddOrder
}

func (mmAddOrder *mOrderRepoFacadeMockAddOrder) invocationsDone() bool {
	if len(mmAddOrder.expectations) == 0 && mmAddOrder.defaultExpectation == nil && mmAddOrder.mock.funcAddOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddOrder.mock.afterAddOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddOrder implements mm_usecase.OrderRepoFacade
func (mmAddOrder *OrderRepoFacadeMock) AddOrder(ctx context.Context, orderDTO dto.OrderDTO) (err error) {
	mm_atomic.AddUint64(&mmAddOrder.beforeAddOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmAddOrder.afterAddOrderCounter, 1)

	mmAddOrder.t.Helper()

	if mmAddOrder.inspectFuncAddOrder != nil {
		mmAddOrder.inspectFuncAddOrder(ctx, orderDTO)
	}

	mm_params := OrderRepoFacadeMockAddOrderParams{ctx, orderDTO}

	// Record call args
	mmAddOrder.AddOrderMock.mutex.Lock()
	mmAddOrder.AddOrderMock.callArgs = append(mmAddOrder.AddOrderMock.callArgs, &mm_params)
	mmAddOrder.AddOrderMock.mutex.Unlock()

	for _, e := range mmAddOrder.AddOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddOrder.AddOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddOrder.AddOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmAddOrder.AddOrderMock.defaultExpectation.params
		mm_want_ptrs := mmAddOrder.AddOrderMock.defaultExpectation.paramPtrs

		mm_got := OrderRepoFacadeMockAddOrderParams{ctx, orderDTO}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddOrder.t.Errorf("OrderRepoFacadeMock.AddOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderDTO != nil && !minimock.Equal(*mm_want_ptrs.orderDTO, mm_got.orderDTO) {
				mmAddOrder.t.Errorf("OrderRepoFacadeMock.AddOrder got unexpected parameter orderDTO, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.originOrderDTO, *mm_want_ptrs.orderDTO, mm_got.orderDTO, minimock.Diff(*mm_want_ptrs.orderDTO, mm_got.orderDTO))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddOrder.t.Errorf("OrderRepoFacadeMock.AddOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddOrder.AddOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmAddOrder.t.Fatal("No results are set for the OrderRepoFacadeMock.AddOrder")
		}
		return (*mm_results).err
	}
	if mmAddOrder.funcAddOrder != nil {
		return mmAddOrder.funcAddOrder(ctx, orderDTO)
	}
	mmAddOrder.t.Fatalf("Unexpected call to OrderRepoFacadeMock.AddOrder. %v %v", ctx, orderDTO)
	return
}

// AddOrderAfterCounter returns a count of finished OrderRepoFacadeMock.AddOrder invocations
func (mmAddOrder *OrderRepoFacadeMock) AddOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrder.afterAddOrderCounter)
}

// AddOrderBeforeCounter returns a count of OrderRepoFacadeMock.AddOrder invocations
func (mmAddOrder *OrderRepoFacadeMock) AddOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrder.beforeAddOrderCounter)
}

// Calls returns a list of arguments used in each call to OrderRepoFacadeMock.AddOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddOrder *mOrderRepoFacadeMockAddOrder) Calls() []*OrderRepoFacadeMockAddOrderParams {
	mmAddOrder.mutex.RLock()

	argCopy := make([]*OrderRepoFacadeMockAddOrderParams, len(mmAddOrder.callArgs))
	copy(argCopy, mmAddOrder.callArgs)

	mmAddOrder.mutex.RUnlock()

	return argCopy
}

// MinimockAddOrderDone returns true if the count of the AddOrder invocations corresponds
// the number of defined expectations
func (m *OrderRepoFacadeMock) MinimockAddOrderDone() bool {
	if m.AddOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddOrderMock.invocationsDone()
}

// MinimockAddOrderInspect logs each unmet expectation
func (m *OrderRepoFacadeMock) MinimockAddOrderInspect() {
	for _, e := range m.AddOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepoFacadeMock.AddOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddOrderCounter := mm_atomic.LoadUint64(&m.afterAddOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddOrderMock.defaultExpectation != nil && afterAddOrderCounter < 1 {
		if m.AddOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepoFacadeMock.AddOrder at\n%s", m.AddOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepoFacadeMock.AddOrder at\n%s with params: %#v", m.AddOrderMock.defaultExpectation.expectationOrigins.origin, *m.AddOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddOrder != nil && afterAddOrderCounter < 1 {
		m.t.Errorf("Expected call to OrderRepoFacadeMock.AddOrder at\n%s", m.funcAddOrderOrigin)
	}

	if !m.AddOrderMock.invocationsDone() && afterAddOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepoFacadeMock.AddOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddOrderMock.expectedInvocations), m.AddOrderMock.expectedInvocationsOrigin, afterAddOrderCounter)
	}
}

type mOrderRepoFacadeMockGetClientOrdersList struct {
	optional           bool
	mock               *OrderRepoFacadeMock
	defaultExpectation *OrderRepoFacadeMockGetClientOrdersListExpectation
	expectations       []*OrderRepoFacadeMockGetClientOrdersListExpectation

	callArgs []*OrderRepoFacadeMockGetClientOrdersListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepoFacadeMockGetClientOrdersListExpectation specifies expectation struct of the OrderRepoFacade.GetClientOrdersList
type OrderRepoFacadeMockGetClientOrdersListExpectation struct {
	mock               *OrderRepoFacadeMock
	params             *OrderRepoFacadeMockGetClientOrdersListParams
	paramPtrs          *OrderRepoFacadeMockGetClientOrdersListParamPtrs
	expectationOrigins OrderRepoFacadeMockGetClientOrdersListExpectationOrigins
	results            *OrderRepoFacadeMockGetClientOrdersListResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepoFacadeMockGetClientOrdersListParams contains parameters of the OrderRepoFacade.GetClientOrdersList
type OrderRepoFacadeMockGetClientOrdersListParams struct {
	ctx      context.Context
	clientID int
}

// OrderRepoFacadeMockGetClientOrdersListParamPtrs contains pointers to parameters of the OrderRepoFacade.GetClientOrdersList
type OrderRepoFacadeMockGetClientOrdersListParamPtrs struct {
	ctx      *context.Context
	clientID *int
}

// OrderRepoFacadeMockGetClientOrdersListResults contains results of the OrderRepoFacade.GetClientOrdersList
type OrderRepoFacadeMockGetClientOrdersListResults struct {
	lp1 *dto.ListOrdersDTO
	err error
}

// OrderRepoFacadeMockGetClientOrdersListOrigins contains origins of expectations of the OrderRepoFacade.GetClientOrdersList
type OrderRepoFacadeMockGetClientOrdersListExpectationOrigins struct {
	origin         string
	originCtx      string
	originClientID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetClientOrdersList *mOrderRepoFacadeMockGetClientOrdersList) Optional() *mOrderRepoFacadeMockGetClientOrdersList {
	mmGetClientOrdersList.optional = true
	return mmGetClientOrdersList
}

// Expect sets up expected params for OrderRepoFacade.GetClientOrdersList
func (mmGetClientOrdersList *mOrderRepoFacadeMockGetClientOrdersList) Expect(ctx context.Context, clientID int) *mOrderRepoFacadeMockGetClientOrdersList {
	if mmGetClientOrdersList.mock.funcGetClientOrdersList != nil {
		mmGetClientOrdersList.mock.t.Fatalf("OrderRepoFacadeMock.GetClientOrdersList mock is already set by Set")
	}

	if mmGetClientOrdersList.defaultExpectation == nil {
		mmGetClientOrdersList.defaultExpectation = &OrderRepoFacadeMockGetClientOrdersListExpectation{}
	}

	if mmGetClientOrdersList.defaultExpectation.paramPtrs != nil {
		mmGetClientOrdersList.mock.t.Fatalf("OrderRepoFacadeMock.GetClientOrdersList mock is already set by ExpectParams functions")
	}

	mmGetClientOrdersList.defaultExpectation.params = &OrderRepoFacadeMockGetClientOrdersListParams{ctx, clientID}
	mmGetClientOrdersList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetClientOrdersList.expectations {
		if minimock.Equal(e.params, mmGetClientOrdersList.defaultExpectation.params) {
			mmGetClientOrdersList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetClientOrdersList.defaultExpectation.params)
		}
	}

	return mmGetClientOrdersList
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepoFacade.GetClientOrdersList
func (mmGetClientOrdersList *mOrderRepoFacadeMockGetClientOrdersList) ExpectCtxParam1(ctx context.Context) *mOrderRepoFacadeMockGetClientOrdersList {
	if mmGetClientOrdersList.mock.funcGetClientOrdersList != nil {
		mmGetClientOrdersList.mock.t.Fatalf("OrderRepoFacadeMock.GetClientOrdersList mock is already set by Set")
	}

	if mmGetClientOrdersList.defaultExpectation == nil {
		mmGetClientOrdersList.defaultExpectation = &OrderRepoFacadeMockGetClientOrdersListExpectation{}
	}

	if mmGetClientOrdersList.defaultExpectation.params != nil {
		mmGetClientOrdersList.mock.t.Fatalf("OrderRepoFacadeMock.GetClientOrdersList mock is already set by Expect")
	}

	if mmGetClientOrdersList.defaultExpectation.paramPtrs == nil {
		mmGetClientOrdersList.defaultExpectation.paramPtrs = &OrderRepoFacadeMockGetClientOrdersListParamPtrs{}
	}
	mmGetClientOrdersList.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetClientOrdersList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetClientOrdersList
}

// ExpectClientIDParam2 sets up expected param clientID for OrderRepoFacade.GetClientOrdersList
func (mmGetClientOrdersList *mOrderRepoFacadeMockGetClientOrdersList) ExpectClientIDParam2(clientID int) *mOrderRepoFacadeMockGetClientOrdersList {
	if mmGetClientOrdersList.mock.funcGetClientOrdersList != nil {
		mmGetClientOrdersList.mock.t.Fatalf("OrderRepoFacadeMock.GetClientOrdersList mock is already set by Set")
	}

	if mmGetClientOrdersList.defaultExpectation == nil {
		mmGetClientOrdersList.defaultExpectation = &OrderRepoFacadeMockGetClientOrdersListExpectation{}
	}

	if mmGetClientOrdersList.defaultExpectation.params != nil {
		mmGetClientOrdersList.mock.t.Fatalf("OrderRepoFacadeMock.GetClientOrdersList mock is already set by Expect")
	}

	if mmGetClientOrdersList.defaultExpectation.paramPtrs == nil {
		mmGetClientOrdersList.defaultExpectation.paramPtrs = &OrderRepoFacadeMockGetClientOrdersListParamPtrs{}
	}
	mmGetClientOrdersList.defaultExpectation.paramPtrs.clientID = &clientID
	mmGetClientOrdersList.defaultExpectation.expectationOrigins.originClientID = minimock.CallerInfo(1)

	return mmGetClientOrdersList
}

// Inspect accepts an inspector function that has same arguments as the OrderRepoFacade.GetClientOrdersList
func (mmGetClientOrdersList *mOrderRepoFacadeMockGetClientOrdersList) Inspect(f func(ctx context.Context, clientID int)) *mOrderRepoFacadeMockGetClientOrdersList {
	if mmGetClientOrdersList.mock.inspectFuncGetClientOrdersList != nil {
		mmGetClientOrdersList.mock.t.Fatalf("Inspect function is already set for OrderRepoFacadeMock.GetClientOrdersList")
	}

	mmGetClientOrdersList.mock.inspectFuncGetClientOrdersList = f

	return mmGetClientOrdersList
}

// Return sets up results that will be returned by OrderRepoFacade.GetClientOrdersList
func (mmGetClientOrdersList *mOrderRepoFacadeMockGetClientOrdersList) Return(lp1 *dto.ListOrdersDTO, err error) *OrderRepoFacadeMock {
	if mmGetClientOrdersList.mock.funcGetClientOrdersList != nil {
		mmGetClientOrdersList.mock.t.Fatalf("OrderRepoFacadeMock.GetClientOrdersList mock is already set by Set")
	}

	if mmGetClientOrdersList.defaultExpectation == nil {
		mmGetClientOrdersList.defaultExpectation = &OrderRepoFacadeMockGetClientOrdersListExpectation{mock: mmGetClientOrdersList.mock}
	}
	mmGetClientOrdersList.defaultExpectation.results = &OrderRepoFacadeMockGetClientOrdersListResults{lp1, err}
	mmGetClientOrdersList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetClientOrdersList.mock
}

// Set uses given function f to mock the OrderRepoFacade.GetClientOrdersList method
func (mmGetClientOrdersList *mOrderRepoFacadeMockGetClientOrdersList) Set(f func(ctx context.Context, clientID int) (lp1 *dto.ListOrdersDTO, err error)) *OrderRepoFacadeMock {
	if mmGetClientOrdersList.defaultExpectation != nil {
		mmGetClientOrdersList.mock.t.Fatalf("Default expectation is already set for the OrderRepoFacade.GetClientOrdersList method")
	}

	if len(mmGetClientOrdersList.expectations) > 0 {
		mmGetClientOrdersList.mock.t.Fatalf("Some expectations are already set for the OrderRepoFacade.GetClientOrdersList method")
	}

	mmGetClientOrdersList.mock.funcGetClientOrdersList = f
	mmGetClientOrdersList.mock.funcGetClientOrdersListOrigin = minimock.CallerInfo(1)
	return mmGetClientOrdersList.mock
}

// When sets expectation for the OrderRepoFacade.GetClientOrdersList which will trigger the result defined by the following
// Then helper
func (mmGetClientOrdersList *mOrderRepoFacadeMockGetClientOrdersList) When(ctx context.Context, clientID int) *OrderRepoFacadeMockGetClientOrdersListExpectation {
	if mmGetClientOrdersList.mock.funcGetClientOrdersList != nil {
		mmGetClientOrdersList.mock.t.Fatalf("OrderRepoFacadeMock.GetClientOrdersList mock is already set by Set")
	}

	expectation := &OrderRepoFacadeMockGetClientOrdersListExpectation{
		mock:               mmGetClientOrdersList.mock,
		params:             &OrderRepoFacadeMockGetClientOrdersListParams{ctx, clientID},
		expectationOrigins: OrderRepoFacadeMockGetClientOrdersListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetClientOrdersList.expectations = append(mmGetClientOrdersList.expectations, expectation)
	return expectation
}

// Then sets up OrderRepoFacade.GetClientOrdersList return parameters for the expectation previously defined by the When method
func (e *OrderRepoFacadeMockGetClientOrdersListExpectation) Then(lp1 *dto.ListOrdersDTO, err error) *OrderRepoFacadeMock {
	e.results = &OrderRepoFacadeMockGetClientOrdersListResults{lp1, err}
	return e.mock
}

// Times sets number of times OrderRepoFacade.GetClientOrdersList should be invoked
func (mmGetClientOrdersList *mOrderRepoFacadeMockGetClientOrdersList) Times(n uint64) *mOrderRepoFacadeMockGetClientOrdersList {
	if n == 0 {
		mmGetClientOrdersList.mock.t.Fatalf("Times of OrderRepoFacadeMock.GetClientOrdersList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetClientOrdersList.expectedInvocations, n)
	mmGetClientOrdersList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetClientOrdersList
}

func (mmGetClientOrdersList *mOrderRepoFacadeMockGetClientOrdersList) invocationsDone() bool {
	if len(mmGetClientOrdersList.expectations) == 0 && mmGetClientOrdersList.defaultExpectation == nil && mmGetClientOrdersList.mock.funcGetClientOrdersList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetClientOrdersList.mock.afterGetClientOrdersListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetClientOrdersList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetClientOrdersList implements mm_usecase.OrderRepoFacade
func (mmGetClientOrdersList *OrderRepoFacadeMock) GetClientOrdersList(ctx context.Context, clientID int) (lp1 *dto.ListOrdersDTO, err error) {
	mm_atomic.AddUint64(&mmGetClientOrdersList.beforeGetClientOrdersListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetClientOrdersList.afterGetClientOrdersListCounter, 1)

	mmGetClientOrdersList.t.Helper()

	if mmGetClientOrdersList.inspectFuncGetClientOrdersList != nil {
		mmGetClientOrdersList.inspectFuncGetClientOrdersList(ctx, clientID)
	}

	mm_params := OrderRepoFacadeMockGetClientOrdersListParams{ctx, clientID}

	// Record call args
	mmGetClientOrdersList.GetClientOrdersListMock.mutex.Lock()
	mmGetClientOrdersList.GetClientOrdersListMock.callArgs = append(mmGetClientOrdersList.GetClientOrdersListMock.callArgs, &mm_params)
	mmGetClientOrdersList.GetClientOrdersListMock.mutex.Unlock()

	for _, e := range mmGetClientOrdersList.GetClientOrdersListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation.Counter, 1)
		mm_want := mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation.params
		mm_want_ptrs := mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation.paramPtrs

		mm_got := OrderRepoFacadeMockGetClientOrdersListParams{ctx, clientID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetClientOrdersList.t.Errorf("OrderRepoFacadeMock.GetClientOrdersList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.clientID != nil && !minimock.Equal(*mm_want_ptrs.clientID, mm_got.clientID) {
				mmGetClientOrdersList.t.Errorf("OrderRepoFacadeMock.GetClientOrdersList got unexpected parameter clientID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation.expectationOrigins.originClientID, *mm_want_ptrs.clientID, mm_got.clientID, minimock.Diff(*mm_want_ptrs.clientID, mm_got.clientID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetClientOrdersList.t.Errorf("OrderRepoFacadeMock.GetClientOrdersList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetClientOrdersList.t.Fatal("No results are set for the OrderRepoFacadeMock.GetClientOrdersList")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmGetClientOrdersList.funcGetClientOrdersList != nil {
		return mmGetClientOrdersList.funcGetClientOrdersList(ctx, clientID)
	}
	mmGetClientOrdersList.t.Fatalf("Unexpected call to OrderRepoFacadeMock.GetClientOrdersList. %v %v", ctx, clientID)
	return
}

// GetClientOrdersListAfterCounter returns a count of finished OrderRepoFacadeMock.GetClientOrdersList invocations
func (mmGetClientOrdersList *OrderRepoFacadeMock) GetClientOrdersListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClientOrdersList.afterGetClientOrdersListCounter)
}

// GetClientOrdersListBeforeCounter returns a count of OrderRepoFacadeMock.GetClientOrdersList invocations
func (mmGetClientOrdersList *OrderRepoFacadeMock) GetClientOrdersListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClientOrdersList.beforeGetClientOrdersListCounter)
}

// Calls returns a list of arguments used in each call to OrderRepoFacadeMock.GetClientOrdersList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetClientOrdersList *mOrderRepoFacadeMockGetClientOrdersList) Calls() []*OrderRepoFacadeMockGetClientOrdersListParams {
	mmGetClientOrdersList.mutex.RLock()

	argCopy := make([]*OrderRepoFacadeMockGetClientOrdersListParams, len(mmGetClientOrdersList.callArgs))
	copy(argCopy, mmGetClientOrdersList.callArgs)

	mmGetClientOrdersList.mutex.RUnlock()

	return argCopy
}

// MinimockGetClientOrdersListDone returns true if the count of the GetClientOrdersList invocations corresponds
// the number of defined expectations
func (m *OrderRepoFacadeMock) MinimockGetClientOrdersListDone() bool {
	if m.GetClientOrdersListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetClientOrdersListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetClientOrdersListMock.invocationsDone()
}

// MinimockGetClientOrdersListInspect logs each unmet expectation
func (m *OrderRepoFacadeMock) MinimockGetClientOrdersListInspect() {
	for _, e := range m.GetClientOrdersListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepoFacadeMock.GetClientOrdersList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetClientOrdersListCounter := mm_atomic.LoadUint64(&m.afterGetClientOrdersListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetClientOrdersListMock.defaultExpectation != nil && afterGetClientOrdersListCounter < 1 {
		if m.GetClientOrdersListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepoFacadeMock.GetClientOrdersList at\n%s", m.GetClientOrdersListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepoFacadeMock.GetClientOrdersList at\n%s with params: %#v", m.GetClientOrdersListMock.defaultExpectation.expectationOrigins.origin, *m.GetClientOrdersListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetClientOrdersList != nil && afterGetClientOrdersListCounter < 1 {
		m.t.Errorf("Expected call to OrderRepoFacadeMock.GetClientOrdersList at\n%s", m.funcGetClientOrdersListOrigin)
	}

	if !m.GetClientOrdersListMock.invocationsDone() && afterGetClientOrdersListCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepoFacadeMock.GetClientOrdersList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetClientOrdersListMock.expectedInvocations), m.GetClientOrdersListMock.expectedInvocationsOrigin, afterGetClientOrdersListCounter)
	}
}

type mOrderRepoFacadeMockGetOrderByID struct {
	optional           bool
	mock               *OrderRepoFacadeMock
	defaultExpectation *OrderRepoFacadeMockGetOrderByIDExpectation
	expectations       []*OrderRepoFacadeMockGetOrderByIDExpectation

	callArgs []*OrderRepoFacadeMockGetOrderByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepoFacadeMockGetOrderByIDExpectation specifies expectation struct of the OrderRepoFacade.GetOrderByID
type OrderRepoFacadeMockGetOrderByIDExpectation struct {
	mock               *OrderRepoFacadeMock
	params             *OrderRepoFacadeMockGetOrderByIDParams
	paramPtrs          *OrderRepoFacadeMockGetOrderByIDParamPtrs
	expectationOrigins OrderRepoFacadeMockGetOrderByIDExpectationOrigins
	results            *OrderRepoFacadeMockGetOrderByIDResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepoFacadeMockGetOrderByIDParams contains parameters of the OrderRepoFacade.GetOrderByID
type OrderRepoFacadeMockGetOrderByIDParams struct {
	ctx context.Context
	id  int64
}

// OrderRepoFacadeMockGetOrderByIDParamPtrs contains pointers to parameters of the OrderRepoFacade.GetOrderByID
type OrderRepoFacadeMockGetOrderByIDParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// OrderRepoFacadeMockGetOrderByIDResults contains results of the OrderRepoFacade.GetOrderByID
type OrderRepoFacadeMockGetOrderByIDResults struct {
	op1 *dto.OrderDTO
	err error
}

// OrderRepoFacadeMockGetOrderByIDOrigins contains origins of expectations of the OrderRepoFacade.GetOrderByID
type OrderRepoFacadeMockGetOrderByIDExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrderByID *mOrderRepoFacadeMockGetOrderByID) Optional() *mOrderRepoFacadeMockGetOrderByID {
	mmGetOrderByID.optional = true
	return mmGetOrderByID
}

// Expect sets up expected params for OrderRepoFacade.GetOrderByID
func (mmGetOrderByID *mOrderRepoFacadeMockGetOrderByID) Expect(ctx context.Context, id int64) *mOrderRepoFacadeMockGetOrderByID {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepoFacadeMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &OrderRepoFacadeMockGetOrderByIDExpectation{}
	}

	if mmGetOrderByID.defaultExpectation.paramPtrs != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepoFacadeMock.GetOrderByID mock is already set by ExpectParams functions")
	}

	mmGetOrderByID.defaultExpectation.params = &OrderRepoFacadeMockGetOrderByIDParams{ctx, id}
	mmGetOrderByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrderByID.expectations {
		if minimock.Equal(e.params, mmGetOrderByID.defaultExpectation.params) {
			mmGetOrderByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrderByID.defaultExpectation.params)
		}
	}

	return mmGetOrderByID
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepoFacade.GetOrderByID
func (mmGetOrderByID *mOrderRepoFacadeMockGetOrderByID) ExpectCtxParam1(ctx context.Context) *mOrderRepoFacadeMockGetOrderByID {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepoFacadeMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &OrderRepoFacadeMockGetOrderByIDExpectation{}
	}

	if mmGetOrderByID.defaultExpectation.params != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepoFacadeMock.GetOrderByID mock is already set by Expect")
	}

	if mmGetOrderByID.defaultExpectation.paramPtrs == nil {
		mmGetOrderByID.defaultExpectation.paramPtrs = &OrderRepoFacadeMockGetOrderByIDParamPtrs{}
	}
	mmGetOrderByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrderByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrderByID
}

// ExpectIdParam2 sets up expected param id for OrderRepoFacade.GetOrderByID
func (mmGetOrderByID *mOrderRepoFacadeMockGetOrderByID) ExpectIdParam2(id int64) *mOrderRepoFacadeMockGetOrderByID {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepoFacadeMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &OrderRepoFacadeMockGetOrderByIDExpectation{}
	}

	if mmGetOrderByID.defaultExpectation.params != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepoFacadeMock.GetOrderByID mock is already set by Expect")
	}

	if mmGetOrderByID.defaultExpectation.paramPtrs == nil {
		mmGetOrderByID.defaultExpectation.paramPtrs = &OrderRepoFacadeMockGetOrderByIDParamPtrs{}
	}
	mmGetOrderByID.defaultExpectation.paramPtrs.id = &id
	mmGetOrderByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetOrderByID
}

// Inspect accepts an inspector function that has same arguments as the OrderRepoFacade.GetOrderByID
func (mmGetOrderByID *mOrderRepoFacadeMockGetOrderByID) Inspect(f func(ctx context.Context, id int64)) *mOrderRepoFacadeMockGetOrderByID {
	if mmGetOrderByID.mock.inspectFuncGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("Inspect function is already set for OrderRepoFacadeMock.GetOrderByID")
	}

	mmGetOrderByID.mock.inspectFuncGetOrderByID = f

	return mmGetOrderByID
}

// Return sets up results that will be returned by OrderRepoFacade.GetOrderByID
func (mmGetOrderByID *mOrderRepoFacadeMockGetOrderByID) Return(op1 *dto.OrderDTO, err error) *OrderRepoFacadeMock {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepoFacadeMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &OrderRepoFacadeMockGetOrderByIDExpectation{mock: mmGetOrderByID.mock}
	}
	mmGetOrderByID.defaultExpectation.results = &OrderRepoFacadeMockGetOrderByIDResults{op1, err}
	mmGetOrderByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrderByID.mock
}

// Set uses given function f to mock the OrderRepoFacade.GetOrderByID method
func (mmGetOrderByID *mOrderRepoFacadeMockGetOrderByID) Set(f func(ctx context.Context, id int64) (op1 *dto.OrderDTO, err error)) *OrderRepoFacadeMock {
	if mmGetOrderByID.defaultExpectation != nil {
		mmGetOrderByID.mock.t.Fatalf("Default expectation is already set for the OrderRepoFacade.GetOrderByID method")
	}

	if len(mmGetOrderByID.expectations) > 0 {
		mmGetOrderByID.mock.t.Fatalf("Some expectations are already set for the OrderRepoFacade.GetOrderByID method")
	}

	mmGetOrderByID.mock.funcGetOrderByID = f
	mmGetOrderByID.mock.funcGetOrderByIDOrigin = minimock.CallerInfo(1)
	return mmGetOrderByID.mock
}

// When sets expectation for the OrderRepoFacade.GetOrderByID which will trigger the result defined by the following
// Then helper
func (mmGetOrderByID *mOrderRepoFacadeMockGetOrderByID) When(ctx context.Context, id int64) *OrderRepoFacadeMockGetOrderByIDExpectation {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepoFacadeMock.GetOrderByID mock is already set by Set")
	}

	expectation := &OrderRepoFacadeMockGetOrderByIDExpectation{
		mock:               mmGetOrderByID.mock,
		params:             &OrderRepoFacadeMockGetOrderByIDParams{ctx, id},
		expectationOrigins: OrderRepoFacadeMockGetOrderByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrderByID.expectations = append(mmGetOrderByID.expectations, expectation)
	return expectation
}

// Then sets up OrderRepoFacade.GetOrderByID return parameters for the expectation previously defined by the When method
func (e *OrderRepoFacadeMockGetOrderByIDExpectation) Then(op1 *dto.OrderDTO, err error) *OrderRepoFacadeMock {
	e.results = &OrderRepoFacadeMockGetOrderByIDResults{op1, err}
	return e.mock
}

// Times sets number of times OrderRepoFacade.GetOrderByID should be invoked
func (mmGetOrderByID *mOrderRepoFacadeMockGetOrderByID) Times(n uint64) *mOrderRepoFacadeMockGetOrderByID {
	if n == 0 {
		mmGetOrderByID.mock.t.Fatalf("Times of OrderRepoFacadeMock.GetOrderByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrderByID.expectedInvocations, n)
	mmGetOrderByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrderByID
}

func (mmGetOrderByID *mOrderRepoFacadeMockGetOrderByID) invocationsDone() bool {
	if len(mmGetOrderByID.expectations) == 0 && mmGetOrderByID.defaultExpectation == nil && mmGetOrderByID.mock.funcGetOrderByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrderByID.mock.afterGetOrderByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrderByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrderByID implements mm_usecase.OrderRepoFacade
func (mmGetOrderByID *OrderRepoFacadeMock) GetOrderByID(ctx context.Context, id int64) (op1 *dto.OrderDTO, err error) {
	mm_atomic.AddUint64(&mmGetOrderByID.beforeGetOrderByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrderByID.afterGetOrderByIDCounter, 1)

	mmGetOrderByID.t.Helper()

	if mmGetOrderByID.inspectFuncGetOrderByID != nil {
		mmGetOrderByID.inspectFuncGetOrderByID(ctx, id)
	}

	mm_params := OrderRepoFacadeMockGetOrderByIDParams{ctx, id}

	// Record call args
	mmGetOrderByID.GetOrderByIDMock.mutex.Lock()
	mmGetOrderByID.GetOrderByIDMock.callArgs = append(mmGetOrderByID.GetOrderByIDMock.callArgs, &mm_params)
	mmGetOrderByID.GetOrderByIDMock.mutex.Unlock()

	for _, e := range mmGetOrderByID.GetOrderByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetOrderByID.GetOrderByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrderByID.GetOrderByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrderByID.GetOrderByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrderByID.GetOrderByIDMock.defaultExpectation.paramPtrs

		mm_got := OrderRepoFacadeMockGetOrderByIDParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrderByID.t.Errorf("OrderRepoFacadeMock.GetOrderByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrderByID.GetOrderByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetOrderByID.t.Errorf("OrderRepoFacadeMock.GetOrderByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrderByID.GetOrderByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrderByID.t.Errorf("OrderRepoFacadeMock.GetOrderByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrderByID.GetOrderByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrderByID.GetOrderByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrderByID.t.Fatal("No results are set for the OrderRepoFacadeMock.GetOrderByID")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetOrderByID.funcGetOrderByID != nil {
		return mmGetOrderByID.funcGetOrderByID(ctx, id)
	}
	mmGetOrderByID.t.Fatalf("Unexpected call to OrderRepoFacadeMock.GetOrderByID. %v %v", ctx, id)
	return
}

// GetOrderByIDAfterCounter returns a count of finished OrderRepoFacadeMock.GetOrderByID invocations
func (mmGetOrderByID *OrderRepoFacadeMock) GetOrderByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderByID.afterGetOrderByIDCounter)
}

// GetOrderByIDBeforeCounter returns a count of OrderRepoFacadeMock.GetOrderByID invocations
func (mmGetOrderByID *OrderRepoFacadeMock) GetOrderByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderByID.beforeGetOrderByIDCounter)
}

// Calls returns a list of arguments used in each call to OrderRepoFacadeMock.GetOrderByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrderByID *mOrderRepoFacadeMockGetOrderByID) Calls() []*OrderRepoFacadeMockGetOrderByIDParams {
	mmGetOrderByID.mutex.RLock()

	argCopy := make([]*OrderRepoFacadeMockGetOrderByIDParams, len(mmGetOrderByID.callArgs))
	copy(argCopy, mmGetOrderByID.callArgs)

	mmGetOrderByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderByIDDone returns true if the count of the GetOrderByID invocations corresponds
// the number of defined expectations
func (m *OrderRepoFacadeMock) MinimockGetOrderByIDDone() bool {
	if m.GetOrderByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrderByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrderByIDMock.invocationsDone()
}

// MinimockGetOrderByIDInspect logs each unmet expectation
func (m *OrderRepoFacadeMock) MinimockGetOrderByIDInspect() {
	for _, e := range m.GetOrderByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepoFacadeMock.GetOrderByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrderByIDCounter := mm_atomic.LoadUint64(&m.afterGetOrderByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderByIDMock.defaultExpectation != nil && afterGetOrderByIDCounter < 1 {
		if m.GetOrderByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepoFacadeMock.GetOrderByID at\n%s", m.GetOrderByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepoFacadeMock.GetOrderByID at\n%s with params: %#v", m.GetOrderByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetOrderByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderByID != nil && afterGetOrderByIDCounter < 1 {
		m.t.Errorf("Expected call to OrderRepoFacadeMock.GetOrderByID at\n%s", m.funcGetOrderByIDOrigin)
	}

	if !m.GetOrderByIDMock.invocationsDone() && afterGetOrderByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepoFacadeMock.GetOrderByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrderByIDMock.expectedInvocations), m.GetOrderByIDMock.expectedInvocationsOrigin, afterGetOrderByIDCounter)
	}
}

type mOrderRepoFacadeMockGetOrdersByIDs struct {
	optional           bool
	mock               *OrderRepoFacadeMock
	defaultExpectation *OrderRepoFacadeMockGetOrdersByIDsExpectation
	expectations       []*OrderRepoFacadeMockGetOrdersByIDsExpectation

	callArgs []*OrderRepoFacadeMockGetOrdersByIDsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepoFacadeMockGetOrdersByIDsExpectation specifies expectation struct of the OrderRepoFacade.GetOrdersByIDs
type OrderRepoFacadeMockGetOrdersByIDsExpectation struct {
	mock               *OrderRepoFacadeMock
	params             *OrderRepoFacadeMockGetOrdersByIDsParams
	paramPtrs          *OrderRepoFacadeMockGetOrdersByIDsParamPtrs
	expectationOrigins OrderRepoFacadeMockGetOrdersByIDsExpectationOrigins
	results            *OrderRepoFacadeMockGetOrdersByIDsResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepoFacadeMockGetOrdersByIDsParams contains parameters of the OrderRepoFacade.GetOrdersByIDs
type OrderRepoFacadeMockGetOrdersByIDsParams struct {
	ctx context.Context
	ids []int64
}

// OrderRepoFacadeMockGetOrdersByIDsParamPtrs contains pointers to parameters of the OrderRepoFacade.GetOrdersByIDs
type OrderRepoFacadeMockGetOrdersByIDsParamPtrs struct {
	ctx *context.Context
	ids *[]int64
}

// OrderRepoFacadeMockGetOrdersByIDsResults contains results of the OrderRepoFacade.GetOrdersByIDs
type OrderRepoFacadeMockGetOrdersByIDsResults struct {
	lp1 *dto.ListOrdersDTO
	err error
}

// OrderRepoFacadeMockGetOrdersByIDsOrigins contains origins of expectations of the OrderRepoFacade.GetOrdersByIDs
type OrderRepoFacadeMockGetOrdersByIDsExpectationOrigins struct {
	origin    string
	originCtx string
	originIds string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrdersByIDs *mOrderRepoFacadeMockGetOrdersByIDs) Optional() *mOrderRepoFacadeMockGetOrdersByIDs {
	mmGetOrdersByIDs.optional = true
	return mmGetOrdersByIDs
}

// Expect sets up expected params for OrderRepoFacade.GetOrdersByIDs
func (mmGetOrdersByIDs *mOrderRepoFacadeMockGetOrdersByIDs) Expect(ctx context.Context, ids []int64) *mOrderRepoFacadeMockGetOrdersByIDs {
	if mmGetOrdersByIDs.mock.funcGetOrdersByIDs != nil {
		mmGetOrdersByIDs.mock.t.Fatalf("OrderRepoFacadeMock.GetOrdersByIDs mock is already set by Set")
	}

	if mmGetOrdersByIDs.defaultExpectation == nil {
		mmGetOrdersByIDs.defaultExpectation = &OrderRepoFacadeMockGetOrdersByIDsExpectation{}
	}

	if mmGetOrdersByIDs.defaultExpectation.paramPtrs != nil {
		mmGetOrdersByIDs.mock.t.Fatalf("OrderRepoFacadeMock.GetOrdersByIDs mock is already set by ExpectParams functions")
	}

	mmGetOrdersByIDs.defaultExpectation.params = &OrderRepoFacadeMockGetOrdersByIDsParams{ctx, ids}
	mmGetOrdersByIDs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrdersByIDs.expectations {
		if minimock.Equal(e.params, mmGetOrdersByIDs.defaultExpectation.params) {
			mmGetOrdersByIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrdersByIDs.defaultExpectation.params)
		}
	}

	return mmGetOrdersByIDs
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepoFacade.GetOrdersByIDs
func (mmGetOrdersByIDs *mOrderRepoFacadeMockGetOrdersByIDs) ExpectCtxParam1(ctx context.Context) *mOrderRepoFacadeMockGetOrdersByIDs {
	if mmGetOrdersByIDs.mock.funcGetOrdersByIDs != nil {
		mmGetOrdersByIDs.mock.t.Fatalf("OrderRepoFacadeMock.GetOrdersByIDs mock is already set by Set")
	}

	if mmGetOrdersByIDs.defaultExpectation == nil {
		mmGetOrdersByIDs.defaultExpectation = &OrderRepoFacadeMockGetOrdersByIDsExpectation{}
	}

	if mmGetOrdersByIDs.defaultExpectation.params != nil {
		mmGetOrdersByIDs.mock.t.Fatalf("OrderRepoFacadeMock.GetOrdersByIDs mock is already set by Expect")
	}

	if mmGetOrdersByIDs.defaultExpectation.paramPtrs == nil {
		mmGetOrdersByIDs.defaultExpectation.paramPtrs = &OrderRepoFacadeMockGetOrdersByIDsParamPtrs{}
	}
	mmGetOrdersByIDs.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOrdersByIDs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOrdersByIDs
}

// ExpectIdsParam2 sets up expected param ids for OrderRepoFacade.GetOrdersByIDs
func (mmGetOrdersByIDs *mOrderRepoFacadeMockGetOrdersByIDs) ExpectIdsParam2(ids []int64) *mOrderRepoFacadeMockGetOrdersByIDs {
	if mmGetOrdersByIDs.mock.funcGetOrdersByIDs != nil {
		mmGetOrdersByIDs.mock.t.Fatalf("OrderRepoFacadeMock.GetOrdersByIDs mock is already set by Set")
	}

	if mmGetOrdersByIDs.defaultExpectation == nil {
		mmGetOrdersByIDs.defaultExpectation = &OrderRepoFacadeMockGetOrdersByIDsExpectation{}
	}

	if mmGetOrdersByIDs.defaultExpectation.params != nil {
		mmGetOrdersByIDs.mock.t.Fatalf("OrderRepoFacadeMock.GetOrdersByIDs mock is already set by Expect")
	}

	if mmGetOrdersByIDs.defaultExpectation.paramPtrs == nil {
		mmGetOrdersByIDs.defaultExpectation.paramPtrs = &OrderRepoFacadeMockGetOrdersByIDsParamPtrs{}
	}
	mmGetOrdersByIDs.defaultExpectation.paramPtrs.ids = &ids
	mmGetOrdersByIDs.defaultExpectation.expectationOrigins.originIds = minimock.CallerInfo(1)

	return mmGetOrdersByIDs
}

// Inspect accepts an inspector function that has same arguments as the OrderRepoFacade.GetOrdersByIDs
func (mmGetOrdersByIDs *mOrderRepoFacadeMockGetOrdersByIDs) Inspect(f func(ctx context.Context, ids []int64)) *mOrderRepoFacadeMockGetOrdersByIDs {
	if mmGetOrdersByIDs.mock.inspectFuncGetOrdersByIDs != nil {
		mmGetOrdersByIDs.mock.t.Fatalf("Inspect function is already set for OrderRepoFacadeMock.GetOrdersByIDs")
	}

	mmGetOrdersByIDs.mock.inspectFuncGetOrdersByIDs = f

	return mmGetOrdersByIDs
}

// Return sets up results that will be returned by OrderRepoFacade.GetOrdersByIDs
func (mmGetOrdersByIDs *mOrderRepoFacadeMockGetOrdersByIDs) Return(lp1 *dto.ListOrdersDTO, err error) *OrderRepoFacadeMock {
	if mmGetOrdersByIDs.mock.funcGetOrdersByIDs != nil {
		mmGetOrdersByIDs.mock.t.Fatalf("OrderRepoFacadeMock.GetOrdersByIDs mock is already set by Set")
	}

	if mmGetOrdersByIDs.defaultExpectation == nil {
		mmGetOrdersByIDs.defaultExpectation = &OrderRepoFacadeMockGetOrdersByIDsExpectation{mock: mmGetOrdersByIDs.mock}
	}
	mmGetOrdersByIDs.defaultExpectation.results = &OrderRepoFacadeMockGetOrdersByIDsResults{lp1, err}
	mmGetOrdersByIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrdersByIDs.mock
}

// Set uses given function f to mock the OrderRepoFacade.GetOrdersByIDs method
func (mmGetOrdersByIDs *mOrderRepoFacadeMockGetOrdersByIDs) Set(f func(ctx context.Context, ids []int64) (lp1 *dto.ListOrdersDTO, err error)) *OrderRepoFacadeMock {
	if mmGetOrdersByIDs.defaultExpectation != nil {
		mmGetOrdersByIDs.mock.t.Fatalf("Default expectation is already set for the OrderRepoFacade.GetOrdersByIDs method")
	}

	if len(mmGetOrdersByIDs.expectations) > 0 {
		mmGetOrdersByIDs.mock.t.Fatalf("Some expectations are already set for the OrderRepoFacade.GetOrdersByIDs method")
	}

	mmGetOrdersByIDs.mock.funcGetOrdersByIDs = f
	mmGetOrdersByIDs.mock.funcGetOrdersByIDsOrigin = minimock.CallerInfo(1)
	return mmGetOrdersByIDs.mock
}

// When sets expectation for the OrderRepoFacade.GetOrdersByIDs which will trigger the result defined by the following
// Then helper
func (mmGetOrdersByIDs *mOrderRepoFacadeMockGetOrdersByIDs) When(ctx context.Context, ids []int64) *OrderRepoFacadeMockGetOrdersByIDsExpectation {
	if mmGetOrdersByIDs.mock.funcGetOrdersByIDs != nil {
		mmGetOrdersByIDs.mock.t.Fatalf("OrderRepoFacadeMock.GetOrdersByIDs mock is already set by Set")
	}

	expectation := &OrderRepoFacadeMockGetOrdersByIDsExpectation{
		mock:               mmGetOrdersByIDs.mock,
		params:             &OrderRepoFacadeMockGetOrdersByIDsParams{ctx, ids},
		expectationOrigins: OrderRepoFacadeMockGetOrdersByIDsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrdersByIDs.expectations = append(mmGetOrdersByIDs.expectations, expectation)
	return expectation
}

// Then sets up OrderRepoFacade.GetOrdersByIDs return parameters for the expectation previously defined by the When method
func (e *OrderRepoFacadeMockGetOrdersByIDsExpectation) Then(lp1 *dto.ListOrdersDTO, err error) *OrderRepoFacadeMock {
	e.results = &OrderRepoFacadeMockGetOrdersByIDsResults{lp1, err}
	return e.mock
}

// Times sets number of times OrderRepoFacade.GetOrdersByIDs should be invoked
func (mmGetOrdersByIDs *mOrderRepoFacadeMockGetOrdersByIDs) Times(n uint64) *mOrderRepoFacadeMockGetOrdersByIDs {
	if n == 0 {
		mmGetOrdersByIDs.mock.t.Fatalf("Times of OrderRepoFacadeMock.GetOrdersByIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrdersByIDs.expectedInvocations, n)
	mmGetOrdersByIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrdersByIDs
}

func (mmGetOrdersByIDs *mOrderRepoFacadeMockGetOrdersByIDs) invocationsDone() bool {
	if len(mmGetOrdersByIDs.expectations) == 0 && mmGetOrdersByIDs.defaultExpectation == nil && mmGetOrdersByIDs.mock.funcGetOrdersByIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrdersByIDs.mock.afterGetOrdersByIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrdersByIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrdersByIDs implements mm_usecase.OrderRepoFacade
func (mmGetOrdersByIDs *OrderRepoFacadeMock) GetOrdersByIDs(ctx context.Context, ids []int64) (lp1 *dto.ListOrdersDTO, err error) {
	mm_atomic.AddUint64(&mmGetOrdersByIDs.beforeGetOrdersByIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrdersByIDs.afterGetOrdersByIDsCounter, 1)

	mmGetOrdersByIDs.t.Helper()

	if mmGetOrdersByIDs.inspectFuncGetOrdersByIDs != nil {
		mmGetOrdersByIDs.inspectFuncGetOrdersByIDs(ctx, ids)
	}

	mm_params := OrderRepoFacadeMockGetOrdersByIDsParams{ctx, ids}

	// Record call args
	mmGetOrdersByIDs.GetOrdersByIDsMock.mutex.Lock()
	mmGetOrdersByIDs.GetOrdersByIDsMock.callArgs = append(mmGetOrdersByIDs.GetOrdersByIDsMock.callArgs, &mm_params)
	mmGetOrdersByIDs.GetOrdersByIDsMock.mutex.Unlock()

	for _, e := range mmGetOrdersByIDs.GetOrdersByIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmGetOrdersByIDs.GetOrdersByIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrdersByIDs.GetOrdersByIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrdersByIDs.GetOrdersByIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrdersByIDs.GetOrdersByIDsMock.defaultExpectation.paramPtrs

		mm_got := OrderRepoFacadeMockGetOrdersByIDsParams{ctx, ids}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrdersByIDs.t.Errorf("OrderRepoFacadeMock.GetOrdersByIDs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrdersByIDs.GetOrdersByIDsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ids != nil && !minimock.Equal(*mm_want_ptrs.ids, mm_got.ids) {
				mmGetOrdersByIDs.t.Errorf("OrderRepoFacadeMock.GetOrdersByIDs got unexpected parameter ids, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrdersByIDs.GetOrdersByIDsMock.defaultExpectation.expectationOrigins.originIds, *mm_want_ptrs.ids, mm_got.ids, minimock.Diff(*mm_want_ptrs.ids, mm_got.ids))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrdersByIDs.t.Errorf("OrderRepoFacadeMock.GetOrdersByIDs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrdersByIDs.GetOrdersByIDsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrdersByIDs.GetOrdersByIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrdersByIDs.t.Fatal("No results are set for the OrderRepoFacadeMock.GetOrdersByIDs")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmGetOrdersByIDs.funcGetOrdersByIDs != nil {
		return mmGetOrdersByIDs.funcGetOrdersByIDs(ctx, ids)
	}
	mmGetOrdersByIDs.t.Fatalf("Unexpected call to OrderRepoFacadeMock.GetOrdersByIDs. %v %v", ctx, ids)
	return
}

// GetOrdersByIDsAfterCounter returns a count of finished OrderRepoFacadeMock.GetOrdersByIDs invocations
func (mmGetOrdersByIDs *OrderRepoFacadeMock) GetOrdersByIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrdersByIDs.afterGetOrdersByIDsCounter)
}

// GetOrdersByIDsBeforeCounter returns a count of OrderRepoFacadeMock.GetOrdersByIDs invocations
func (mmGetOrdersByIDs *OrderRepoFacadeMock) GetOrdersByIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrdersByIDs.beforeGetOrdersByIDsCounter)
}

// Calls returns a list of arguments used in each call to OrderRepoFacadeMock.GetOrdersByIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrdersByIDs *mOrderRepoFacadeMockGetOrdersByIDs) Calls() []*OrderRepoFacadeMockGetOrdersByIDsParams {
	mmGetOrdersByIDs.mutex.RLock()

	argCopy := make([]*OrderRepoFacadeMockGetOrdersByIDsParams, len(mmGetOrdersByIDs.callArgs))
	copy(argCopy, mmGetOrdersByIDs.callArgs)

	mmGetOrdersByIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrdersByIDsDone returns true if the count of the GetOrdersByIDs invocations corresponds
// the number of defined expectations
func (m *OrderRepoFacadeMock) MinimockGetOrdersByIDsDone() bool {
	if m.GetOrdersByIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrdersByIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrdersByIDsMock.invocationsDone()
}

// MinimockGetOrdersByIDsInspect logs each unmet expectation
func (m *OrderRepoFacadeMock) MinimockGetOrdersByIDsInspect() {
	for _, e := range m.GetOrdersByIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepoFacadeMock.GetOrdersByIDs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrdersByIDsCounter := mm_atomic.LoadUint64(&m.afterGetOrdersByIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrdersByIDsMock.defaultExpectation != nil && afterGetOrdersByIDsCounter < 1 {
		if m.GetOrdersByIDsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepoFacadeMock.GetOrdersByIDs at\n%s", m.GetOrdersByIDsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepoFacadeMock.GetOrdersByIDs at\n%s with params: %#v", m.GetOrdersByIDsMock.defaultExpectation.expectationOrigins.origin, *m.GetOrdersByIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrdersByIDs != nil && afterGetOrdersByIDsCounter < 1 {
		m.t.Errorf("Expected call to OrderRepoFacadeMock.GetOrdersByIDs at\n%s", m.funcGetOrdersByIDsOrigin)
	}

	if !m.GetOrdersByIDsMock.invocationsDone() && afterGetOrdersByIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepoFacadeMock.GetOrdersByIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrdersByIDsMock.expectedInvocations), m.GetOrdersByIDsMock.expectedInvocationsOrigin, afterGetOrdersByIDsCounter)
	}
}

type mOrderRepoFacadeMockGetRefundsList struct {
	optional           bool
	mock               *OrderRepoFacadeMock
	defaultExpectation *OrderRepoFacadeMockGetRefundsListExpectation
	expectations       []*OrderRepoFacadeMockGetRefundsListExpectation

	callArgs []*OrderRepoFacadeMockGetRefundsListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepoFacadeMockGetRefundsListExpectation specifies expectation struct of the OrderRepoFacade.GetRefundsList
type OrderRepoFacadeMockGetRefundsListExpectation struct {
	mock               *OrderRepoFacadeMock
	params             *OrderRepoFacadeMockGetRefundsListParams
	paramPtrs          *OrderRepoFacadeMockGetRefundsListParamPtrs
	expectationOrigins OrderRepoFacadeMockGetRefundsListExpectationOrigins
	results            *OrderRepoFacadeMockGetRefundsListResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepoFacadeMockGetRefundsListParams contains parameters of the OrderRepoFacade.GetRefundsList
type OrderRepoFacadeMockGetRefundsListParams struct {
	ctx    context.Context
	limit  int
	offset int
}

// OrderRepoFacadeMockGetRefundsListParamPtrs contains pointers to parameters of the OrderRepoFacade.GetRefundsList
type OrderRepoFacadeMockGetRefundsListParamPtrs struct {
	ctx    *context.Context
	limit  *int
	offset *int
}

// OrderRepoFacadeMockGetRefundsListResults contains results of the OrderRepoFacade.GetRefundsList
type OrderRepoFacadeMockGetRefundsListResults struct {
	lp1 *dto.ListOrdersDTO
	err error
}

// OrderRepoFacadeMockGetRefundsListOrigins contains origins of expectations of the OrderRepoFacade.GetRefundsList
type OrderRepoFacadeMockGetRefundsListExpectationOrigins struct {
	origin       string
	originCtx    string
	originLimit  string
	originOffset string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRefundsList *mOrderRepoFacadeMockGetRefundsList) Optional() *mOrderRepoFacadeMockGetRefundsList {
	mmGetRefundsList.optional = true
	return mmGetRefundsList
}

// Expect sets up expected params for OrderRepoFacade.GetRefundsList
func (mmGetRefundsList *mOrderRepoFacadeMockGetRefundsList) Expect(ctx context.Context, limit int, offset int) *mOrderRepoFacadeMockGetRefundsList {
	if mmGetRefundsList.mock.funcGetRefundsList != nil {
		mmGetRefundsList.mock.t.Fatalf("OrderRepoFacadeMock.GetRefundsList mock is already set by Set")
	}

	if mmGetRefundsList.defaultExpectation == nil {
		mmGetRefundsList.defaultExpectation = &OrderRepoFacadeMockGetRefundsListExpectation{}
	}

	if mmGetRefundsList.defaultExpectation.paramPtrs != nil {
		mmGetRefundsList.mock.t.Fatalf("OrderRepoFacadeMock.GetRefundsList mock is already set by ExpectParams functions")
	}

	mmGetRefundsList.defaultExpectation.params = &OrderRepoFacadeMockGetRefundsListParams{ctx, limit, offset}
	mmGetRefundsList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetRefundsList.expectations {
		if minimock.Equal(e.params, mmGetRefundsList.defaultExpectation.params) {
			mmGetRefundsList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRefundsList.defaultExpectation.params)
		}
	}

	return mmGetRefundsList
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepoFacade.GetRefundsList
func (mmGetRefundsList *mOrderRepoFacadeMockGetRefundsList) ExpectCtxParam1(ctx context.Context) *mOrderRepoFacadeMockGetRefundsList {
	if mmGetRefundsList.mock.funcGetRefundsList != nil {
		mmGetRefundsList.mock.t.Fatalf("OrderRepoFacadeMock.GetRefundsList mock is already set by Set")
	}

	if mmGetRefundsList.defaultExpectation == nil {
		mmGetRefundsList.defaultExpectation = &OrderRepoFacadeMockGetRefundsListExpectation{}
	}

	if mmGetRefundsList.defaultExpectation.params != nil {
		mmGetRefundsList.mock.t.Fatalf("OrderRepoFacadeMock.GetRefundsList mock is already set by Expect")
	}

	if mmGetRefundsList.defaultExpectation.paramPtrs == nil {
		mmGetRefundsList.defaultExpectation.paramPtrs = &OrderRepoFacadeMockGetRefundsListParamPtrs{}
	}
	mmGetRefundsList.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetRefundsList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetRefundsList
}

// ExpectLimitParam2 sets up expected param limit for OrderRepoFacade.GetRefundsList
func (mmGetRefundsList *mOrderRepoFacadeMockGetRefundsList) ExpectLimitParam2(limit int) *mOrderRepoFacadeMockGetRefundsList {
	if mmGetRefundsList.mock.funcGetRefundsList != nil {
		mmGetRefundsList.mock.t.Fatalf("OrderRepoFacadeMock.GetRefundsList mock is already set by Set")
	}

	if mmGetRefundsList.defaultExpectation == nil {
		mmGetRefundsList.defaultExpectation = &OrderRepoFacadeMockGetRefundsListExpectation{}
	}

	if mmGetRefundsList.defaultExpectation.params != nil {
		mmGetRefundsList.mock.t.Fatalf("OrderRepoFacadeMock.GetRefundsList mock is already set by Expect")
	}

	if mmGetRefundsList.defaultExpectation.paramPtrs == nil {
		mmGetRefundsList.defaultExpectation.paramPtrs = &OrderRepoFacadeMockGetRefundsListParamPtrs{}
	}
	mmGetRefundsList.defaultExpectation.paramPtrs.limit = &limit
	mmGetRefundsList.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmGetRefundsList
}

// ExpectOffsetParam3 sets up expected param offset for OrderRepoFacade.GetRefundsList
func (mmGetRefundsList *mOrderRepoFacadeMockGetRefundsList) ExpectOffsetParam3(offset int) *mOrderRepoFacadeMockGetRefundsList {
	if mmGetRefundsList.mock.funcGetRefundsList != nil {
		mmGetRefundsList.mock.t.Fatalf("OrderRepoFacadeMock.GetRefundsList mock is already set by Set")
	}

	if mmGetRefundsList.defaultExpectation == nil {
		mmGetRefundsList.defaultExpectation = &OrderRepoFacadeMockGetRefundsListExpectation{}
	}

	if mmGetRefundsList.defaultExpectation.params != nil {
		mmGetRefundsList.mock.t.Fatalf("OrderRepoFacadeMock.GetRefundsList mock is already set by Expect")
	}

	if mmGetRefundsList.defaultExpectation.paramPtrs == nil {
		mmGetRefundsList.defaultExpectation.paramPtrs = &OrderRepoFacadeMockGetRefundsListParamPtrs{}
	}
	mmGetRefundsList.defaultExpectation.paramPtrs.offset = &offset
	mmGetRefundsList.defaultExpectation.expectationOrigins.originOffset = minimock.CallerInfo(1)

	return mmGetRefundsList
}

// Inspect accepts an inspector function that has same arguments as the OrderRepoFacade.GetRefundsList
func (mmGetRefundsList *mOrderRepoFacadeMockGetRefundsList) Inspect(f func(ctx context.Context, limit int, offset int)) *mOrderRepoFacadeMockGetRefundsList {
	if mmGetRefundsList.mock.inspectFuncGetRefundsList != nil {
		mmGetRefundsList.mock.t.Fatalf("Inspect function is already set for OrderRepoFacadeMock.GetRefundsList")
	}

	mmGetRefundsList.mock.inspectFuncGetRefundsList = f

	return mmGetRefundsList
}

// Return sets up results that will be returned by OrderRepoFacade.GetRefundsList
func (mmGetRefundsList *mOrderRepoFacadeMockGetRefundsList) Return(lp1 *dto.ListOrdersDTO, err error) *OrderRepoFacadeMock {
	if mmGetRefundsList.mock.funcGetRefundsList != nil {
		mmGetRefundsList.mock.t.Fatalf("OrderRepoFacadeMock.GetRefundsList mock is already set by Set")
	}

	if mmGetRefundsList.defaultExpectation == nil {
		mmGetRefundsList.defaultExpectation = &OrderRepoFacadeMockGetRefundsListExpectation{mock: mmGetRefundsList.mock}
	}
	mmGetRefundsList.defaultExpectation.results = &OrderRepoFacadeMockGetRefundsListResults{lp1, err}
	mmGetRefundsList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetRefundsList.mock
}

// Set uses given function f to mock the OrderRepoFacade.GetRefundsList method
func (mmGetRefundsList *mOrderRepoFacadeMockGetRefundsList) Set(f func(ctx context.Context, limit int, offset int) (lp1 *dto.ListOrdersDTO, err error)) *OrderRepoFacadeMock {
	if mmGetRefundsList.defaultExpectation != nil {
		mmGetRefundsList.mock.t.Fatalf("Default expectation is already set for the OrderRepoFacade.GetRefundsList method")
	}

	if len(mmGetRefundsList.expectations) > 0 {
		mmGetRefundsList.mock.t.Fatalf("Some expectations are already set for the OrderRepoFacade.GetRefundsList method")
	}

	mmGetRefundsList.mock.funcGetRefundsList = f
	mmGetRefundsList.mock.funcGetRefundsListOrigin = minimock.CallerInfo(1)
	return mmGetRefundsList.mock
}

// When sets expectation for the OrderRepoFacade.GetRefundsList which will trigger the result defined by the following
// Then helper
func (mmGetRefundsList *mOrderRepoFacadeMockGetRefundsList) When(ctx context.Context, limit int, offset int) *OrderRepoFacadeMockGetRefundsListExpectation {
	if mmGetRefundsList.mock.funcGetRefundsList != nil {
		mmGetRefundsList.mock.t.Fatalf("OrderRepoFacadeMock.GetRefundsList mock is already set by Set")
	}

	expectation := &OrderRepoFacadeMockGetRefundsListExpectation{
		mock:               mmGetRefundsList.mock,
		params:             &OrderRepoFacadeMockGetRefundsListParams{ctx, limit, offset},
		expectationOrigins: OrderRepoFacadeMockGetRefundsListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetRefundsList.expectations = append(mmGetRefundsList.expectations, expectation)
	return expectation
}

// Then sets up OrderRepoFacade.GetRefundsList return parameters for the expectation previously defined by the When method
func (e *OrderRepoFacadeMockGetRefundsListExpectation) Then(lp1 *dto.ListOrdersDTO, err error) *OrderRepoFacadeMock {
	e.results = &OrderRepoFacadeMockGetRefundsListResults{lp1, err}
	return e.mock
}

// Times sets number of times OrderRepoFacade.GetRefundsList should be invoked
func (mmGetRefundsList *mOrderRepoFacadeMockGetRefundsList) Times(n uint64) *mOrderRepoFacadeMockGetRefundsList {
	if n == 0 {
		mmGetRefundsList.mock.t.Fatalf("Times of OrderRepoFacadeMock.GetRefundsList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRefundsList.expectedInvocations, n)
	mmGetRefundsList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetRefundsList
}

func (mmGetRefundsList *mOrderRepoFacadeMockGetRefundsList) invocationsDone() bool {
	if len(mmGetRefundsList.expectations) == 0 && mmGetRefundsList.defaultExpectation == nil && mmGetRefundsList.mock.funcGetRefundsList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRefundsList.mock.afterGetRefundsListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRefundsList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRefundsList implements mm_usecase.OrderRepoFacade
func (mmGetRefundsList *OrderRepoFacadeMock) GetRefundsList(ctx context.Context, limit int, offset int) (lp1 *dto.ListOrdersDTO, err error) {
	mm_atomic.AddUint64(&mmGetRefundsList.beforeGetRefundsListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRefundsList.afterGetRefundsListCounter, 1)

	mmGetRefundsList.t.Helper()

	if mmGetRefundsList.inspectFuncGetRefundsList != nil {
		mmGetRefundsList.inspectFuncGetRefundsList(ctx, limit, offset)
	}

	mm_params := OrderRepoFacadeMockGetRefundsListParams{ctx, limit, offset}

	// Record call args
	mmGetRefundsList.GetRefundsListMock.mutex.Lock()
	mmGetRefundsList.GetRefundsListMock.callArgs = append(mmGetRefundsList.GetRefundsListMock.callArgs, &mm_params)
	mmGetRefundsList.GetRefundsListMock.mutex.Unlock()

	for _, e := range mmGetRefundsList.GetRefundsListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmGetRefundsList.GetRefundsListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRefundsList.GetRefundsListMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRefundsList.GetRefundsListMock.defaultExpectation.params
		mm_want_ptrs := mmGetRefundsList.GetRefundsListMock.defaultExpectation.paramPtrs

		mm_got := OrderRepoFacadeMockGetRefundsListParams{ctx, limit, offset}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetRefundsList.t.Errorf("OrderRepoFacadeMock.GetRefundsList got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRefundsList.GetRefundsListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetRefundsList.t.Errorf("OrderRepoFacadeMock.GetRefundsList got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRefundsList.GetRefundsListMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

			if mm_want_ptrs.offset != nil && !minimock.Equal(*mm_want_ptrs.offset, mm_got.offset) {
				mmGetRefundsList.t.Errorf("OrderRepoFacadeMock.GetRefundsList got unexpected parameter offset, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRefundsList.GetRefundsListMock.defaultExpectation.expectationOrigins.originOffset, *mm_want_ptrs.offset, mm_got.offset, minimock.Diff(*mm_want_ptrs.offset, mm_got.offset))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRefundsList.t.Errorf("OrderRepoFacadeMock.GetRefundsList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetRefundsList.GetRefundsListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRefundsList.GetRefundsListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRefundsList.t.Fatal("No results are set for the OrderRepoFacadeMock.GetRefundsList")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmGetRefundsList.funcGetRefundsList != nil {
		return mmGetRefundsList.funcGetRefundsList(ctx, limit, offset)
	}
	mmGetRefundsList.t.Fatalf("Unexpected call to OrderRepoFacadeMock.GetRefundsList. %v %v %v", ctx, limit, offset)
	return
}

// GetRefundsListAfterCounter returns a count of finished OrderRepoFacadeMock.GetRefundsList invocations
func (mmGetRefundsList *OrderRepoFacadeMock) GetRefundsListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefundsList.afterGetRefundsListCounter)
}

// GetRefundsListBeforeCounter returns a count of OrderRepoFacadeMock.GetRefundsList invocations
func (mmGetRefundsList *OrderRepoFacadeMock) GetRefundsListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefundsList.beforeGetRefundsListCounter)
}

// Calls returns a list of arguments used in each call to OrderRepoFacadeMock.GetRefundsList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRefundsList *mOrderRepoFacadeMockGetRefundsList) Calls() []*OrderRepoFacadeMockGetRefundsListParams {
	mmGetRefundsList.mutex.RLock()

	argCopy := make([]*OrderRepoFacadeMockGetRefundsListParams, len(mmGetRefundsList.callArgs))
	copy(argCopy, mmGetRefundsList.callArgs)

	mmGetRefundsList.mutex.RUnlock()

	return argCopy
}

// MinimockGetRefundsListDone returns true if the count of the GetRefundsList invocations corresponds
// the number of defined expectations
func (m *OrderRepoFacadeMock) MinimockGetRefundsListDone() bool {
	if m.GetRefundsListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRefundsListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRefundsListMock.invocationsDone()
}

// MinimockGetRefundsListInspect logs each unmet expectation
func (m *OrderRepoFacadeMock) MinimockGetRefundsListInspect() {
	for _, e := range m.GetRefundsListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepoFacadeMock.GetRefundsList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetRefundsListCounter := mm_atomic.LoadUint64(&m.afterGetRefundsListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRefundsListMock.defaultExpectation != nil && afterGetRefundsListCounter < 1 {
		if m.GetRefundsListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepoFacadeMock.GetRefundsList at\n%s", m.GetRefundsListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepoFacadeMock.GetRefundsList at\n%s with params: %#v", m.GetRefundsListMock.defaultExpectation.expectationOrigins.origin, *m.GetRefundsListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRefundsList != nil && afterGetRefundsListCounter < 1 {
		m.t.Errorf("Expected call to OrderRepoFacadeMock.GetRefundsList at\n%s", m.funcGetRefundsListOrigin)
	}

	if !m.GetRefundsListMock.invocationsDone() && afterGetRefundsListCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepoFacadeMock.GetRefundsList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetRefundsListMock.expectedInvocations), m.GetRefundsListMock.expectedInvocationsOrigin, afterGetRefundsListCounter)
	}
}

type mOrderRepoFacadeMockUpdateOrder struct {
	optional           bool
	mock               *OrderRepoFacadeMock
	defaultExpectation *OrderRepoFacadeMockUpdateOrderExpectation
	expectations       []*OrderRepoFacadeMockUpdateOrderExpectation

	callArgs []*OrderRepoFacadeMockUpdateOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrderRepoFacadeMockUpdateOrderExpectation specifies expectation struct of the OrderRepoFacade.UpdateOrder
type OrderRepoFacadeMockUpdateOrderExpectation struct {
	mock               *OrderRepoFacadeMock
	params             *OrderRepoFacadeMockUpdateOrderParams
	paramPtrs          *OrderRepoFacadeMockUpdateOrderParamPtrs
	expectationOrigins OrderRepoFacadeMockUpdateOrderExpectationOrigins
	results            *OrderRepoFacadeMockUpdateOrderResults
	returnOrigin       string
	Counter            uint64
}

// OrderRepoFacadeMockUpdateOrderParams contains parameters of the OrderRepoFacade.UpdateOrder
type OrderRepoFacadeMockUpdateOrderParams struct {
	ctx      context.Context
	orderDTO dto.OrderDTO
}

// OrderRepoFacadeMockUpdateOrderParamPtrs contains pointers to parameters of the OrderRepoFacade.UpdateOrder
type OrderRepoFacadeMockUpdateOrderParamPtrs struct {
	ctx      *context.Context
	orderDTO *dto.OrderDTO
}

// OrderRepoFacadeMockUpdateOrderResults contains results of the OrderRepoFacade.UpdateOrder
type OrderRepoFacadeMockUpdateOrderResults struct {
	err error
}

// OrderRepoFacadeMockUpdateOrderOrigins contains origins of expectations of the OrderRepoFacade.UpdateOrder
type OrderRepoFacadeMockUpdateOrderExpectationOrigins struct {
	origin         string
	originCtx      string
	originOrderDTO string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateOrder *mOrderRepoFacadeMockUpdateOrder) Optional() *mOrderRepoFacadeMockUpdateOrder {
	mmUpdateOrder.optional = true
	return mmUpdateOrder
}

// Expect sets up expected params for OrderRepoFacade.UpdateOrder
func (mmUpdateOrder *mOrderRepoFacadeMockUpdateOrder) Expect(ctx context.Context, orderDTO dto.OrderDTO) *mOrderRepoFacadeMockUpdateOrder {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepoFacadeMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &OrderRepoFacadeMockUpdateOrderExpectation{}
	}

	if mmUpdateOrder.defaultExpectation.paramPtrs != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepoFacadeMock.UpdateOrder mock is already set by ExpectParams functions")
	}

	mmUpdateOrder.defaultExpectation.params = &OrderRepoFacadeMockUpdateOrderParams{ctx, orderDTO}
	mmUpdateOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateOrder.expectations {
		if minimock.Equal(e.params, mmUpdateOrder.defaultExpectation.params) {
			mmUpdateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrder.defaultExpectation.params)
		}
	}

	return mmUpdateOrder
}

// ExpectCtxParam1 sets up expected param ctx for OrderRepoFacade.UpdateOrder
func (mmUpdateOrder *mOrderRepoFacadeMockUpdateOrder) ExpectCtxParam1(ctx context.Context) *mOrderRepoFacadeMockUpdateOrder {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepoFacadeMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &OrderRepoFacadeMockUpdateOrderExpectation{}
	}

	if mmUpdateOrder.defaultExpectation.params != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepoFacadeMock.UpdateOrder mock is already set by Expect")
	}

	if mmUpdateOrder.defaultExpectation.paramPtrs == nil {
		mmUpdateOrder.defaultExpectation.paramPtrs = &OrderRepoFacadeMockUpdateOrderParamPtrs{}
	}
	mmUpdateOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateOrder
}

// ExpectOrderDTOParam2 sets up expected param orderDTO for OrderRepoFacade.UpdateOrder
func (mmUpdateOrder *mOrderRepoFacadeMockUpdateOrder) ExpectOrderDTOParam2(orderDTO dto.OrderDTO) *mOrderRepoFacadeMockUpdateOrder {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepoFacadeMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &OrderRepoFacadeMockUpdateOrderExpectation{}
	}

	if mmUpdateOrder.defaultExpectation.params != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepoFacadeMock.UpdateOrder mock is already set by Expect")
	}

	if mmUpdateOrder.defaultExpectation.paramPtrs == nil {
		mmUpdateOrder.defaultExpectation.paramPtrs = &OrderRepoFacadeMockUpdateOrderParamPtrs{}
	}
	mmUpdateOrder.defaultExpectation.paramPtrs.orderDTO = &orderDTO
	mmUpdateOrder.defaultExpectation.expectationOrigins.originOrderDTO = minimock.CallerInfo(1)

	return mmUpdateOrder
}

// Inspect accepts an inspector function that has same arguments as the OrderRepoFacade.UpdateOrder
func (mmUpdateOrder *mOrderRepoFacadeMockUpdateOrder) Inspect(f func(ctx context.Context, orderDTO dto.OrderDTO)) *mOrderRepoFacadeMockUpdateOrder {
	if mmUpdateOrder.mock.inspectFuncUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("Inspect function is already set for OrderRepoFacadeMock.UpdateOrder")
	}

	mmUpdateOrder.mock.inspectFuncUpdateOrder = f

	return mmUpdateOrder
}

// Return sets up results that will be returned by OrderRepoFacade.UpdateOrder
func (mmUpdateOrder *mOrderRepoFacadeMockUpdateOrder) Return(err error) *OrderRepoFacadeMock {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepoFacadeMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &OrderRepoFacadeMockUpdateOrderExpectation{mock: mmUpdateOrder.mock}
	}
	mmUpdateOrder.defaultExpectation.results = &OrderRepoFacadeMockUpdateOrderResults{err}
	mmUpdateOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateOrder.mock
}

// Set uses given function f to mock the OrderRepoFacade.UpdateOrder method
func (mmUpdateOrder *mOrderRepoFacadeMockUpdateOrder) Set(f func(ctx context.Context, orderDTO dto.OrderDTO) (err error)) *OrderRepoFacadeMock {
	if mmUpdateOrder.defaultExpectation != nil {
		mmUpdateOrder.mock.t.Fatalf("Default expectation is already set for the OrderRepoFacade.UpdateOrder method")
	}

	if len(mmUpdateOrder.expectations) > 0 {
		mmUpdateOrder.mock.t.Fatalf("Some expectations are already set for the OrderRepoFacade.UpdateOrder method")
	}

	mmUpdateOrder.mock.funcUpdateOrder = f
	mmUpdateOrder.mock.funcUpdateOrderOrigin = minimock.CallerInfo(1)
	return mmUpdateOrder.mock
}

// When sets expectation for the OrderRepoFacade.UpdateOrder which will trigger the result defined by the following
// Then helper
func (mmUpdateOrder *mOrderRepoFacadeMockUpdateOrder) When(ctx context.Context, orderDTO dto.OrderDTO) *OrderRepoFacadeMockUpdateOrderExpectation {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("OrderRepoFacadeMock.UpdateOrder mock is already set by Set")
	}

	expectation := &OrderRepoFacadeMockUpdateOrderExpectation{
		mock:               mmUpdateOrder.mock,
		params:             &OrderRepoFacadeMockUpdateOrderParams{ctx, orderDTO},
		expectationOrigins: OrderRepoFacadeMockUpdateOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateOrder.expectations = append(mmUpdateOrder.expectations, expectation)
	return expectation
}

// Then sets up OrderRepoFacade.UpdateOrder return parameters for the expectation previously defined by the When method
func (e *OrderRepoFacadeMockUpdateOrderExpectation) Then(err error) *OrderRepoFacadeMock {
	e.results = &OrderRepoFacadeMockUpdateOrderResults{err}
	return e.mock
}

// Times sets number of times OrderRepoFacade.UpdateOrder should be invoked
func (mmUpdateOrder *mOrderRepoFacadeMockUpdateOrder) Times(n uint64) *mOrderRepoFacadeMockUpdateOrder {
	if n == 0 {
		mmUpdateOrder.mock.t.Fatalf("Times of OrderRepoFacadeMock.UpdateOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateOrder.expectedInvocations, n)
	mmUpdateOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateOrder
}

func (mmUpdateOrder *mOrderRepoFacadeMockUpdateOrder) invocationsDone() bool {
	if len(mmUpdateOrder.expectations) == 0 && mmUpdateOrder.defaultExpectation == nil && mmUpdateOrder.mock.funcUpdateOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateOrder.mock.afterUpdateOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateOrder implements mm_usecase.OrderRepoFacade
func (mmUpdateOrder *OrderRepoFacadeMock) UpdateOrder(ctx context.Context, orderDTO dto.OrderDTO) (err error) {
	mm_atomic.AddUint64(&mmUpdateOrder.beforeUpdateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrder.afterUpdateOrderCounter, 1)

	mmUpdateOrder.t.Helper()

	if mmUpdateOrder.inspectFuncUpdateOrder != nil {
		mmUpdateOrder.inspectFuncUpdateOrder(ctx, orderDTO)
	}

	mm_params := OrderRepoFacadeMockUpdateOrderParams{ctx, orderDTO}

	// Record call args
	mmUpdateOrder.UpdateOrderMock.mutex.Lock()
	mmUpdateOrder.UpdateOrderMock.callArgs = append(mmUpdateOrder.UpdateOrderMock.callArgs, &mm_params)
	mmUpdateOrder.UpdateOrderMock.mutex.Unlock()

	for _, e := range mmUpdateOrder.UpdateOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateOrder.UpdateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrder.UpdateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrder.UpdateOrderMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateOrder.UpdateOrderMock.defaultExpectation.paramPtrs

		mm_got := OrderRepoFacadeMockUpdateOrderParams{ctx, orderDTO}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateOrder.t.Errorf("OrderRepoFacadeMock.UpdateOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateOrder.UpdateOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderDTO != nil && !minimock.Equal(*mm_want_ptrs.orderDTO, mm_got.orderDTO) {
				mmUpdateOrder.t.Errorf("OrderRepoFacadeMock.UpdateOrder got unexpected parameter orderDTO, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateOrder.UpdateOrderMock.defaultExpectation.expectationOrigins.originOrderDTO, *mm_want_ptrs.orderDTO, mm_got.orderDTO, minimock.Diff(*mm_want_ptrs.orderDTO, mm_got.orderDTO))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrder.t.Errorf("OrderRepoFacadeMock.UpdateOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateOrder.UpdateOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrder.UpdateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrder.t.Fatal("No results are set for the OrderRepoFacadeMock.UpdateOrder")
		}
		return (*mm_results).err
	}
	if mmUpdateOrder.funcUpdateOrder != nil {
		return mmUpdateOrder.funcUpdateOrder(ctx, orderDTO)
	}
	mmUpdateOrder.t.Fatalf("Unexpected call to OrderRepoFacadeMock.UpdateOrder. %v %v", ctx, orderDTO)
	return
}

// UpdateOrderAfterCounter returns a count of finished OrderRepoFacadeMock.UpdateOrder invocations
func (mmUpdateOrder *OrderRepoFacadeMock) UpdateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrder.afterUpdateOrderCounter)
}

// UpdateOrderBeforeCounter returns a count of OrderRepoFacadeMock.UpdateOrder invocations
func (mmUpdateOrder *OrderRepoFacadeMock) UpdateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrder.beforeUpdateOrderCounter)
}

// Calls returns a list of arguments used in each call to OrderRepoFacadeMock.UpdateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrder *mOrderRepoFacadeMockUpdateOrder) Calls() []*OrderRepoFacadeMockUpdateOrderParams {
	mmUpdateOrder.mutex.RLock()

	argCopy := make([]*OrderRepoFacadeMockUpdateOrderParams, len(mmUpdateOrder.callArgs))
	copy(argCopy, mmUpdateOrder.callArgs)

	mmUpdateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrderDone returns true if the count of the UpdateOrder invocations corresponds
// the number of defined expectations
func (m *OrderRepoFacadeMock) MinimockUpdateOrderDone() bool {
	if m.UpdateOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateOrderMock.invocationsDone()
}

// MinimockUpdateOrderInspect logs each unmet expectation
func (m *OrderRepoFacadeMock) MinimockUpdateOrderInspect() {
	for _, e := range m.UpdateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepoFacadeMock.UpdateOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateOrderCounter := mm_atomic.LoadUint64(&m.afterUpdateOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderMock.defaultExpectation != nil && afterUpdateOrderCounter < 1 {
		if m.UpdateOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrderRepoFacadeMock.UpdateOrder at\n%s", m.UpdateOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrderRepoFacadeMock.UpdateOrder at\n%s with params: %#v", m.UpdateOrderMock.defaultExpectation.expectationOrigins.origin, *m.UpdateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrder != nil && afterUpdateOrderCounter < 1 {
		m.t.Errorf("Expected call to OrderRepoFacadeMock.UpdateOrder at\n%s", m.funcUpdateOrderOrigin)
	}

	if !m.UpdateOrderMock.invocationsDone() && afterUpdateOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepoFacadeMock.UpdateOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateOrderMock.expectedInvocations), m.UpdateOrderMock.expectedInvocationsOrigin, afterUpdateOrderCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderRepoFacadeMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddOrderInspect()

			m.MinimockGetClientOrdersListInspect()

			m.MinimockGetOrderByIDInspect()

			m.MinimockGetOrdersByIDsInspect()

			m.MinimockGetRefundsListInspect()

			m.MinimockUpdateOrderInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderRepoFacadeMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderRepoFacadeMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddOrderDone() &&
		m.MinimockGetClientOrdersListDone() &&
		m.MinimockGetOrderByIDDone() &&
		m.MinimockGetOrdersByIDsDone() &&
		m.MinimockGetRefundsListDone() &&
		m.MinimockUpdateOrderDone()
}
