// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i gitlab.ozon.dev/marchenkosasha2/homework/internal/usecase.orderRepository -o order_repository_mock.go -n RepositoryMock -p mock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/marchenkosasha2/homework/internal/domain"
)

// RepositoryMock implements mm_usecase.orderRepository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddOrder          func(newOrder *domain.Order) (err error)
	funcAddOrderOrigin    string
	inspectFuncAddOrder   func(newOrder *domain.Order)
	afterAddOrderCounter  uint64
	beforeAddOrderCounter uint64
	AddOrderMock          mRepositoryMockAddOrder

	funcGetClientOrdersList          func(clientID int) (opa1 []*domain.Order, err error)
	funcGetClientOrdersListOrigin    string
	inspectFuncGetClientOrdersList   func(clientID int)
	afterGetClientOrdersListCounter  uint64
	beforeGetClientOrdersListCounter uint64
	GetClientOrdersListMock          mRepositoryMockGetClientOrdersList

	funcGetOrderByID          func(id int) (op1 *domain.Order, err error)
	funcGetOrderByIDOrigin    string
	inspectFuncGetOrderByID   func(id int)
	afterGetOrderByIDCounter  uint64
	beforeGetOrderByIDCounter uint64
	GetOrderByIDMock          mRepositoryMockGetOrderByID

	funcGetOrdersByID          func(ids []int) (opa1 []*domain.Order, err error)
	funcGetOrdersByIDOrigin    string
	inspectFuncGetOrdersByID   func(ids []int)
	afterGetOrdersByIDCounter  uint64
	beforeGetOrdersByIDCounter uint64
	GetOrdersByIDMock          mRepositoryMockGetOrdersByID

	funcGetRefundsList          func(limit int, offset int) (opa1 []*domain.Order, err error)
	funcGetRefundsListOrigin    string
	inspectFuncGetRefundsList   func(limit int, offset int)
	afterGetRefundsListCounter  uint64
	beforeGetRefundsListCounter uint64
	GetRefundsListMock          mRepositoryMockGetRefundsList

	funcUpdate          func() (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func()
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mRepositoryMockUpdate
}

// NewRepositoryMock returns a mock for mm_usecase.orderRepository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddOrderMock = mRepositoryMockAddOrder{mock: m}
	m.AddOrderMock.callArgs = []*RepositoryMockAddOrderParams{}

	m.GetClientOrdersListMock = mRepositoryMockGetClientOrdersList{mock: m}
	m.GetClientOrdersListMock.callArgs = []*RepositoryMockGetClientOrdersListParams{}

	m.GetOrderByIDMock = mRepositoryMockGetOrderByID{mock: m}
	m.GetOrderByIDMock.callArgs = []*RepositoryMockGetOrderByIDParams{}

	m.GetOrdersByIDMock = mRepositoryMockGetOrdersByID{mock: m}
	m.GetOrdersByIDMock.callArgs = []*RepositoryMockGetOrdersByIDParams{}

	m.GetRefundsListMock = mRepositoryMockGetRefundsList{mock: m}
	m.GetRefundsListMock.callArgs = []*RepositoryMockGetRefundsListParams{}

	m.UpdateMock = mRepositoryMockUpdate{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockAddOrder struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddOrderExpectation
	expectations       []*RepositoryMockAddOrderExpectation

	callArgs []*RepositoryMockAddOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockAddOrderExpectation specifies expectation struct of the orderRepository.AddOrder
type RepositoryMockAddOrderExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockAddOrderParams
	paramPtrs          *RepositoryMockAddOrderParamPtrs
	expectationOrigins RepositoryMockAddOrderExpectationOrigins
	results            *RepositoryMockAddOrderResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockAddOrderParams contains parameters of the orderRepository.AddOrder
type RepositoryMockAddOrderParams struct {
	newOrder *domain.Order
}

// RepositoryMockAddOrderParamPtrs contains pointers to parameters of the orderRepository.AddOrder
type RepositoryMockAddOrderParamPtrs struct {
	newOrder **domain.Order
}

// RepositoryMockAddOrderResults contains results of the orderRepository.AddOrder
type RepositoryMockAddOrderResults struct {
	err error
}

// RepositoryMockAddOrderOrigins contains origins of expectations of the orderRepository.AddOrder
type RepositoryMockAddOrderExpectationOrigins struct {
	origin         string
	originNewOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddOrder *mRepositoryMockAddOrder) Optional() *mRepositoryMockAddOrder {
	mmAddOrder.optional = true
	return mmAddOrder
}

// Expect sets up expected params for orderRepository.AddOrder
func (mmAddOrder *mRepositoryMockAddOrder) Expect(newOrder *domain.Order) *mRepositoryMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("RepositoryMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &RepositoryMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.paramPtrs != nil {
		mmAddOrder.mock.t.Fatalf("RepositoryMock.AddOrder mock is already set by ExpectParams functions")
	}

	mmAddOrder.defaultExpectation.params = &RepositoryMockAddOrderParams{newOrder}
	mmAddOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddOrder.expectations {
		if minimock.Equal(e.params, mmAddOrder.defaultExpectation.params) {
			mmAddOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddOrder.defaultExpectation.params)
		}
	}

	return mmAddOrder
}

// ExpectNewOrderParam1 sets up expected param newOrder for orderRepository.AddOrder
func (mmAddOrder *mRepositoryMockAddOrder) ExpectNewOrderParam1(newOrder *domain.Order) *mRepositoryMockAddOrder {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("RepositoryMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &RepositoryMockAddOrderExpectation{}
	}

	if mmAddOrder.defaultExpectation.params != nil {
		mmAddOrder.mock.t.Fatalf("RepositoryMock.AddOrder mock is already set by Expect")
	}

	if mmAddOrder.defaultExpectation.paramPtrs == nil {
		mmAddOrder.defaultExpectation.paramPtrs = &RepositoryMockAddOrderParamPtrs{}
	}
	mmAddOrder.defaultExpectation.paramPtrs.newOrder = &newOrder
	mmAddOrder.defaultExpectation.expectationOrigins.originNewOrder = minimock.CallerInfo(1)

	return mmAddOrder
}

// Inspect accepts an inspector function that has same arguments as the orderRepository.AddOrder
func (mmAddOrder *mRepositoryMockAddOrder) Inspect(f func(newOrder *domain.Order)) *mRepositoryMockAddOrder {
	if mmAddOrder.mock.inspectFuncAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddOrder")
	}

	mmAddOrder.mock.inspectFuncAddOrder = f

	return mmAddOrder
}

// Return sets up results that will be returned by orderRepository.AddOrder
func (mmAddOrder *mRepositoryMockAddOrder) Return(err error) *RepositoryMock {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("RepositoryMock.AddOrder mock is already set by Set")
	}

	if mmAddOrder.defaultExpectation == nil {
		mmAddOrder.defaultExpectation = &RepositoryMockAddOrderExpectation{mock: mmAddOrder.mock}
	}
	mmAddOrder.defaultExpectation.results = &RepositoryMockAddOrderResults{err}
	mmAddOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddOrder.mock
}

// Set uses given function f to mock the orderRepository.AddOrder method
func (mmAddOrder *mRepositoryMockAddOrder) Set(f func(newOrder *domain.Order) (err error)) *RepositoryMock {
	if mmAddOrder.defaultExpectation != nil {
		mmAddOrder.mock.t.Fatalf("Default expectation is already set for the orderRepository.AddOrder method")
	}

	if len(mmAddOrder.expectations) > 0 {
		mmAddOrder.mock.t.Fatalf("Some expectations are already set for the orderRepository.AddOrder method")
	}

	mmAddOrder.mock.funcAddOrder = f
	mmAddOrder.mock.funcAddOrderOrigin = minimock.CallerInfo(1)
	return mmAddOrder.mock
}

// When sets expectation for the orderRepository.AddOrder which will trigger the result defined by the following
// Then helper
func (mmAddOrder *mRepositoryMockAddOrder) When(newOrder *domain.Order) *RepositoryMockAddOrderExpectation {
	if mmAddOrder.mock.funcAddOrder != nil {
		mmAddOrder.mock.t.Fatalf("RepositoryMock.AddOrder mock is already set by Set")
	}

	expectation := &RepositoryMockAddOrderExpectation{
		mock:               mmAddOrder.mock,
		params:             &RepositoryMockAddOrderParams{newOrder},
		expectationOrigins: RepositoryMockAddOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddOrder.expectations = append(mmAddOrder.expectations, expectation)
	return expectation
}

// Then sets up orderRepository.AddOrder return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddOrderExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockAddOrderResults{err}
	return e.mock
}

// Times sets number of times orderRepository.AddOrder should be invoked
func (mmAddOrder *mRepositoryMockAddOrder) Times(n uint64) *mRepositoryMockAddOrder {
	if n == 0 {
		mmAddOrder.mock.t.Fatalf("Times of RepositoryMock.AddOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddOrder.expectedInvocations, n)
	mmAddOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddOrder
}

func (mmAddOrder *mRepositoryMockAddOrder) invocationsDone() bool {
	if len(mmAddOrder.expectations) == 0 && mmAddOrder.defaultExpectation == nil && mmAddOrder.mock.funcAddOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddOrder.mock.afterAddOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddOrder implements mm_usecase.orderRepository
func (mmAddOrder *RepositoryMock) AddOrder(newOrder *domain.Order) (err error) {
	mm_atomic.AddUint64(&mmAddOrder.beforeAddOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmAddOrder.afterAddOrderCounter, 1)

	mmAddOrder.t.Helper()

	if mmAddOrder.inspectFuncAddOrder != nil {
		mmAddOrder.inspectFuncAddOrder(newOrder)
	}

	mm_params := RepositoryMockAddOrderParams{newOrder}

	// Record call args
	mmAddOrder.AddOrderMock.mutex.Lock()
	mmAddOrder.AddOrderMock.callArgs = append(mmAddOrder.AddOrderMock.callArgs, &mm_params)
	mmAddOrder.AddOrderMock.mutex.Unlock()

	for _, e := range mmAddOrder.AddOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddOrder.AddOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddOrder.AddOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmAddOrder.AddOrderMock.defaultExpectation.params
		mm_want_ptrs := mmAddOrder.AddOrderMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockAddOrderParams{newOrder}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.newOrder != nil && !minimock.Equal(*mm_want_ptrs.newOrder, mm_got.newOrder) {
				mmAddOrder.t.Errorf("RepositoryMock.AddOrder got unexpected parameter newOrder, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.originNewOrder, *mm_want_ptrs.newOrder, mm_got.newOrder, minimock.Diff(*mm_want_ptrs.newOrder, mm_got.newOrder))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddOrder.t.Errorf("RepositoryMock.AddOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddOrder.AddOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddOrder.AddOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmAddOrder.t.Fatal("No results are set for the RepositoryMock.AddOrder")
		}
		return (*mm_results).err
	}
	if mmAddOrder.funcAddOrder != nil {
		return mmAddOrder.funcAddOrder(newOrder)
	}
	mmAddOrder.t.Fatalf("Unexpected call to RepositoryMock.AddOrder. %v", newOrder)
	return
}

// AddOrderAfterCounter returns a count of finished RepositoryMock.AddOrder invocations
func (mmAddOrder *RepositoryMock) AddOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrder.afterAddOrderCounter)
}

// AddOrderBeforeCounter returns a count of RepositoryMock.AddOrder invocations
func (mmAddOrder *RepositoryMock) AddOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOrder.beforeAddOrderCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddOrder *mRepositoryMockAddOrder) Calls() []*RepositoryMockAddOrderParams {
	mmAddOrder.mutex.RLock()

	argCopy := make([]*RepositoryMockAddOrderParams, len(mmAddOrder.callArgs))
	copy(argCopy, mmAddOrder.callArgs)

	mmAddOrder.mutex.RUnlock()

	return argCopy
}

// MinimockAddOrderDone returns true if the count of the AddOrder invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddOrderDone() bool {
	if m.AddOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddOrderMock.invocationsDone()
}

// MinimockAddOrderInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddOrderInspect() {
	for _, e := range m.AddOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddOrderCounter := mm_atomic.LoadUint64(&m.afterAddOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddOrderMock.defaultExpectation != nil && afterAddOrderCounter < 1 {
		if m.AddOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.AddOrder at\n%s", m.AddOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddOrder at\n%s with params: %#v", m.AddOrderMock.defaultExpectation.expectationOrigins.origin, *m.AddOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddOrder != nil && afterAddOrderCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.AddOrder at\n%s", m.funcAddOrderOrigin)
	}

	if !m.AddOrderMock.invocationsDone() && afterAddOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.AddOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddOrderMock.expectedInvocations), m.AddOrderMock.expectedInvocationsOrigin, afterAddOrderCounter)
	}
}

type mRepositoryMockGetClientOrdersList struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetClientOrdersListExpectation
	expectations       []*RepositoryMockGetClientOrdersListExpectation

	callArgs []*RepositoryMockGetClientOrdersListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetClientOrdersListExpectation specifies expectation struct of the orderRepository.GetClientOrdersList
type RepositoryMockGetClientOrdersListExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetClientOrdersListParams
	paramPtrs          *RepositoryMockGetClientOrdersListParamPtrs
	expectationOrigins RepositoryMockGetClientOrdersListExpectationOrigins
	results            *RepositoryMockGetClientOrdersListResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetClientOrdersListParams contains parameters of the orderRepository.GetClientOrdersList
type RepositoryMockGetClientOrdersListParams struct {
	clientID int
}

// RepositoryMockGetClientOrdersListParamPtrs contains pointers to parameters of the orderRepository.GetClientOrdersList
type RepositoryMockGetClientOrdersListParamPtrs struct {
	clientID *int
}

// RepositoryMockGetClientOrdersListResults contains results of the orderRepository.GetClientOrdersList
type RepositoryMockGetClientOrdersListResults struct {
	opa1 []*domain.Order
	err  error
}

// RepositoryMockGetClientOrdersListOrigins contains origins of expectations of the orderRepository.GetClientOrdersList
type RepositoryMockGetClientOrdersListExpectationOrigins struct {
	origin         string
	originClientID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetClientOrdersList *mRepositoryMockGetClientOrdersList) Optional() *mRepositoryMockGetClientOrdersList {
	mmGetClientOrdersList.optional = true
	return mmGetClientOrdersList
}

// Expect sets up expected params for orderRepository.GetClientOrdersList
func (mmGetClientOrdersList *mRepositoryMockGetClientOrdersList) Expect(clientID int) *mRepositoryMockGetClientOrdersList {
	if mmGetClientOrdersList.mock.funcGetClientOrdersList != nil {
		mmGetClientOrdersList.mock.t.Fatalf("RepositoryMock.GetClientOrdersList mock is already set by Set")
	}

	if mmGetClientOrdersList.defaultExpectation == nil {
		mmGetClientOrdersList.defaultExpectation = &RepositoryMockGetClientOrdersListExpectation{}
	}

	if mmGetClientOrdersList.defaultExpectation.paramPtrs != nil {
		mmGetClientOrdersList.mock.t.Fatalf("RepositoryMock.GetClientOrdersList mock is already set by ExpectParams functions")
	}

	mmGetClientOrdersList.defaultExpectation.params = &RepositoryMockGetClientOrdersListParams{clientID}
	mmGetClientOrdersList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetClientOrdersList.expectations {
		if minimock.Equal(e.params, mmGetClientOrdersList.defaultExpectation.params) {
			mmGetClientOrdersList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetClientOrdersList.defaultExpectation.params)
		}
	}

	return mmGetClientOrdersList
}

// ExpectClientIDParam1 sets up expected param clientID for orderRepository.GetClientOrdersList
func (mmGetClientOrdersList *mRepositoryMockGetClientOrdersList) ExpectClientIDParam1(clientID int) *mRepositoryMockGetClientOrdersList {
	if mmGetClientOrdersList.mock.funcGetClientOrdersList != nil {
		mmGetClientOrdersList.mock.t.Fatalf("RepositoryMock.GetClientOrdersList mock is already set by Set")
	}

	if mmGetClientOrdersList.defaultExpectation == nil {
		mmGetClientOrdersList.defaultExpectation = &RepositoryMockGetClientOrdersListExpectation{}
	}

	if mmGetClientOrdersList.defaultExpectation.params != nil {
		mmGetClientOrdersList.mock.t.Fatalf("RepositoryMock.GetClientOrdersList mock is already set by Expect")
	}

	if mmGetClientOrdersList.defaultExpectation.paramPtrs == nil {
		mmGetClientOrdersList.defaultExpectation.paramPtrs = &RepositoryMockGetClientOrdersListParamPtrs{}
	}
	mmGetClientOrdersList.defaultExpectation.paramPtrs.clientID = &clientID
	mmGetClientOrdersList.defaultExpectation.expectationOrigins.originClientID = minimock.CallerInfo(1)

	return mmGetClientOrdersList
}

// Inspect accepts an inspector function that has same arguments as the orderRepository.GetClientOrdersList
func (mmGetClientOrdersList *mRepositoryMockGetClientOrdersList) Inspect(f func(clientID int)) *mRepositoryMockGetClientOrdersList {
	if mmGetClientOrdersList.mock.inspectFuncGetClientOrdersList != nil {
		mmGetClientOrdersList.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetClientOrdersList")
	}

	mmGetClientOrdersList.mock.inspectFuncGetClientOrdersList = f

	return mmGetClientOrdersList
}

// Return sets up results that will be returned by orderRepository.GetClientOrdersList
func (mmGetClientOrdersList *mRepositoryMockGetClientOrdersList) Return(opa1 []*domain.Order, err error) *RepositoryMock {
	if mmGetClientOrdersList.mock.funcGetClientOrdersList != nil {
		mmGetClientOrdersList.mock.t.Fatalf("RepositoryMock.GetClientOrdersList mock is already set by Set")
	}

	if mmGetClientOrdersList.defaultExpectation == nil {
		mmGetClientOrdersList.defaultExpectation = &RepositoryMockGetClientOrdersListExpectation{mock: mmGetClientOrdersList.mock}
	}
	mmGetClientOrdersList.defaultExpectation.results = &RepositoryMockGetClientOrdersListResults{opa1, err}
	mmGetClientOrdersList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetClientOrdersList.mock
}

// Set uses given function f to mock the orderRepository.GetClientOrdersList method
func (mmGetClientOrdersList *mRepositoryMockGetClientOrdersList) Set(f func(clientID int) (opa1 []*domain.Order, err error)) *RepositoryMock {
	if mmGetClientOrdersList.defaultExpectation != nil {
		mmGetClientOrdersList.mock.t.Fatalf("Default expectation is already set for the orderRepository.GetClientOrdersList method")
	}

	if len(mmGetClientOrdersList.expectations) > 0 {
		mmGetClientOrdersList.mock.t.Fatalf("Some expectations are already set for the orderRepository.GetClientOrdersList method")
	}

	mmGetClientOrdersList.mock.funcGetClientOrdersList = f
	mmGetClientOrdersList.mock.funcGetClientOrdersListOrigin = minimock.CallerInfo(1)
	return mmGetClientOrdersList.mock
}

// When sets expectation for the orderRepository.GetClientOrdersList which will trigger the result defined by the following
// Then helper
func (mmGetClientOrdersList *mRepositoryMockGetClientOrdersList) When(clientID int) *RepositoryMockGetClientOrdersListExpectation {
	if mmGetClientOrdersList.mock.funcGetClientOrdersList != nil {
		mmGetClientOrdersList.mock.t.Fatalf("RepositoryMock.GetClientOrdersList mock is already set by Set")
	}

	expectation := &RepositoryMockGetClientOrdersListExpectation{
		mock:               mmGetClientOrdersList.mock,
		params:             &RepositoryMockGetClientOrdersListParams{clientID},
		expectationOrigins: RepositoryMockGetClientOrdersListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetClientOrdersList.expectations = append(mmGetClientOrdersList.expectations, expectation)
	return expectation
}

// Then sets up orderRepository.GetClientOrdersList return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetClientOrdersListExpectation) Then(opa1 []*domain.Order, err error) *RepositoryMock {
	e.results = &RepositoryMockGetClientOrdersListResults{opa1, err}
	return e.mock
}

// Times sets number of times orderRepository.GetClientOrdersList should be invoked
func (mmGetClientOrdersList *mRepositoryMockGetClientOrdersList) Times(n uint64) *mRepositoryMockGetClientOrdersList {
	if n == 0 {
		mmGetClientOrdersList.mock.t.Fatalf("Times of RepositoryMock.GetClientOrdersList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetClientOrdersList.expectedInvocations, n)
	mmGetClientOrdersList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetClientOrdersList
}

func (mmGetClientOrdersList *mRepositoryMockGetClientOrdersList) invocationsDone() bool {
	if len(mmGetClientOrdersList.expectations) == 0 && mmGetClientOrdersList.defaultExpectation == nil && mmGetClientOrdersList.mock.funcGetClientOrdersList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetClientOrdersList.mock.afterGetClientOrdersListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetClientOrdersList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetClientOrdersList implements mm_usecase.orderRepository
func (mmGetClientOrdersList *RepositoryMock) GetClientOrdersList(clientID int) (opa1 []*domain.Order, err error) {
	mm_atomic.AddUint64(&mmGetClientOrdersList.beforeGetClientOrdersListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetClientOrdersList.afterGetClientOrdersListCounter, 1)

	mmGetClientOrdersList.t.Helper()

	if mmGetClientOrdersList.inspectFuncGetClientOrdersList != nil {
		mmGetClientOrdersList.inspectFuncGetClientOrdersList(clientID)
	}

	mm_params := RepositoryMockGetClientOrdersListParams{clientID}

	// Record call args
	mmGetClientOrdersList.GetClientOrdersListMock.mutex.Lock()
	mmGetClientOrdersList.GetClientOrdersListMock.callArgs = append(mmGetClientOrdersList.GetClientOrdersListMock.callArgs, &mm_params)
	mmGetClientOrdersList.GetClientOrdersListMock.mutex.Unlock()

	for _, e := range mmGetClientOrdersList.GetClientOrdersListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.opa1, e.results.err
		}
	}

	if mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation.Counter, 1)
		mm_want := mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation.params
		mm_want_ptrs := mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetClientOrdersListParams{clientID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.clientID != nil && !minimock.Equal(*mm_want_ptrs.clientID, mm_got.clientID) {
				mmGetClientOrdersList.t.Errorf("RepositoryMock.GetClientOrdersList got unexpected parameter clientID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation.expectationOrigins.originClientID, *mm_want_ptrs.clientID, mm_got.clientID, minimock.Diff(*mm_want_ptrs.clientID, mm_got.clientID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetClientOrdersList.t.Errorf("RepositoryMock.GetClientOrdersList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetClientOrdersList.GetClientOrdersListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetClientOrdersList.t.Fatal("No results are set for the RepositoryMock.GetClientOrdersList")
		}
		return (*mm_results).opa1, (*mm_results).err
	}
	if mmGetClientOrdersList.funcGetClientOrdersList != nil {
		return mmGetClientOrdersList.funcGetClientOrdersList(clientID)
	}
	mmGetClientOrdersList.t.Fatalf("Unexpected call to RepositoryMock.GetClientOrdersList. %v", clientID)
	return
}

// GetClientOrdersListAfterCounter returns a count of finished RepositoryMock.GetClientOrdersList invocations
func (mmGetClientOrdersList *RepositoryMock) GetClientOrdersListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClientOrdersList.afterGetClientOrdersListCounter)
}

// GetClientOrdersListBeforeCounter returns a count of RepositoryMock.GetClientOrdersList invocations
func (mmGetClientOrdersList *RepositoryMock) GetClientOrdersListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetClientOrdersList.beforeGetClientOrdersListCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetClientOrdersList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetClientOrdersList *mRepositoryMockGetClientOrdersList) Calls() []*RepositoryMockGetClientOrdersListParams {
	mmGetClientOrdersList.mutex.RLock()

	argCopy := make([]*RepositoryMockGetClientOrdersListParams, len(mmGetClientOrdersList.callArgs))
	copy(argCopy, mmGetClientOrdersList.callArgs)

	mmGetClientOrdersList.mutex.RUnlock()

	return argCopy
}

// MinimockGetClientOrdersListDone returns true if the count of the GetClientOrdersList invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetClientOrdersListDone() bool {
	if m.GetClientOrdersListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetClientOrdersListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetClientOrdersListMock.invocationsDone()
}

// MinimockGetClientOrdersListInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetClientOrdersListInspect() {
	for _, e := range m.GetClientOrdersListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetClientOrdersList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetClientOrdersListCounter := mm_atomic.LoadUint64(&m.afterGetClientOrdersListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetClientOrdersListMock.defaultExpectation != nil && afterGetClientOrdersListCounter < 1 {
		if m.GetClientOrdersListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetClientOrdersList at\n%s", m.GetClientOrdersListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetClientOrdersList at\n%s with params: %#v", m.GetClientOrdersListMock.defaultExpectation.expectationOrigins.origin, *m.GetClientOrdersListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetClientOrdersList != nil && afterGetClientOrdersListCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetClientOrdersList at\n%s", m.funcGetClientOrdersListOrigin)
	}

	if !m.GetClientOrdersListMock.invocationsDone() && afterGetClientOrdersListCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetClientOrdersList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetClientOrdersListMock.expectedInvocations), m.GetClientOrdersListMock.expectedInvocationsOrigin, afterGetClientOrdersListCounter)
	}
}

type mRepositoryMockGetOrderByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetOrderByIDExpectation
	expectations       []*RepositoryMockGetOrderByIDExpectation

	callArgs []*RepositoryMockGetOrderByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetOrderByIDExpectation specifies expectation struct of the orderRepository.GetOrderByID
type RepositoryMockGetOrderByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetOrderByIDParams
	paramPtrs          *RepositoryMockGetOrderByIDParamPtrs
	expectationOrigins RepositoryMockGetOrderByIDExpectationOrigins
	results            *RepositoryMockGetOrderByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetOrderByIDParams contains parameters of the orderRepository.GetOrderByID
type RepositoryMockGetOrderByIDParams struct {
	id int
}

// RepositoryMockGetOrderByIDParamPtrs contains pointers to parameters of the orderRepository.GetOrderByID
type RepositoryMockGetOrderByIDParamPtrs struct {
	id *int
}

// RepositoryMockGetOrderByIDResults contains results of the orderRepository.GetOrderByID
type RepositoryMockGetOrderByIDResults struct {
	op1 *domain.Order
	err error
}

// RepositoryMockGetOrderByIDOrigins contains origins of expectations of the orderRepository.GetOrderByID
type RepositoryMockGetOrderByIDExpectationOrigins struct {
	origin   string
	originId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrderByID *mRepositoryMockGetOrderByID) Optional() *mRepositoryMockGetOrderByID {
	mmGetOrderByID.optional = true
	return mmGetOrderByID
}

// Expect sets up expected params for orderRepository.GetOrderByID
func (mmGetOrderByID *mRepositoryMockGetOrderByID) Expect(id int) *mRepositoryMockGetOrderByID {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("RepositoryMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &RepositoryMockGetOrderByIDExpectation{}
	}

	if mmGetOrderByID.defaultExpectation.paramPtrs != nil {
		mmGetOrderByID.mock.t.Fatalf("RepositoryMock.GetOrderByID mock is already set by ExpectParams functions")
	}

	mmGetOrderByID.defaultExpectation.params = &RepositoryMockGetOrderByIDParams{id}
	mmGetOrderByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrderByID.expectations {
		if minimock.Equal(e.params, mmGetOrderByID.defaultExpectation.params) {
			mmGetOrderByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrderByID.defaultExpectation.params)
		}
	}

	return mmGetOrderByID
}

// ExpectIdParam1 sets up expected param id for orderRepository.GetOrderByID
func (mmGetOrderByID *mRepositoryMockGetOrderByID) ExpectIdParam1(id int) *mRepositoryMockGetOrderByID {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("RepositoryMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &RepositoryMockGetOrderByIDExpectation{}
	}

	if mmGetOrderByID.defaultExpectation.params != nil {
		mmGetOrderByID.mock.t.Fatalf("RepositoryMock.GetOrderByID mock is already set by Expect")
	}

	if mmGetOrderByID.defaultExpectation.paramPtrs == nil {
		mmGetOrderByID.defaultExpectation.paramPtrs = &RepositoryMockGetOrderByIDParamPtrs{}
	}
	mmGetOrderByID.defaultExpectation.paramPtrs.id = &id
	mmGetOrderByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetOrderByID
}

// Inspect accepts an inspector function that has same arguments as the orderRepository.GetOrderByID
func (mmGetOrderByID *mRepositoryMockGetOrderByID) Inspect(f func(id int)) *mRepositoryMockGetOrderByID {
	if mmGetOrderByID.mock.inspectFuncGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetOrderByID")
	}

	mmGetOrderByID.mock.inspectFuncGetOrderByID = f

	return mmGetOrderByID
}

// Return sets up results that will be returned by orderRepository.GetOrderByID
func (mmGetOrderByID *mRepositoryMockGetOrderByID) Return(op1 *domain.Order, err error) *RepositoryMock {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("RepositoryMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &RepositoryMockGetOrderByIDExpectation{mock: mmGetOrderByID.mock}
	}
	mmGetOrderByID.defaultExpectation.results = &RepositoryMockGetOrderByIDResults{op1, err}
	mmGetOrderByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrderByID.mock
}

// Set uses given function f to mock the orderRepository.GetOrderByID method
func (mmGetOrderByID *mRepositoryMockGetOrderByID) Set(f func(id int) (op1 *domain.Order, err error)) *RepositoryMock {
	if mmGetOrderByID.defaultExpectation != nil {
		mmGetOrderByID.mock.t.Fatalf("Default expectation is already set for the orderRepository.GetOrderByID method")
	}

	if len(mmGetOrderByID.expectations) > 0 {
		mmGetOrderByID.mock.t.Fatalf("Some expectations are already set for the orderRepository.GetOrderByID method")
	}

	mmGetOrderByID.mock.funcGetOrderByID = f
	mmGetOrderByID.mock.funcGetOrderByIDOrigin = minimock.CallerInfo(1)
	return mmGetOrderByID.mock
}

// When sets expectation for the orderRepository.GetOrderByID which will trigger the result defined by the following
// Then helper
func (mmGetOrderByID *mRepositoryMockGetOrderByID) When(id int) *RepositoryMockGetOrderByIDExpectation {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("RepositoryMock.GetOrderByID mock is already set by Set")
	}

	expectation := &RepositoryMockGetOrderByIDExpectation{
		mock:               mmGetOrderByID.mock,
		params:             &RepositoryMockGetOrderByIDParams{id},
		expectationOrigins: RepositoryMockGetOrderByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrderByID.expectations = append(mmGetOrderByID.expectations, expectation)
	return expectation
}

// Then sets up orderRepository.GetOrderByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetOrderByIDExpectation) Then(op1 *domain.Order, err error) *RepositoryMock {
	e.results = &RepositoryMockGetOrderByIDResults{op1, err}
	return e.mock
}

// Times sets number of times orderRepository.GetOrderByID should be invoked
func (mmGetOrderByID *mRepositoryMockGetOrderByID) Times(n uint64) *mRepositoryMockGetOrderByID {
	if n == 0 {
		mmGetOrderByID.mock.t.Fatalf("Times of RepositoryMock.GetOrderByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrderByID.expectedInvocations, n)
	mmGetOrderByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrderByID
}

func (mmGetOrderByID *mRepositoryMockGetOrderByID) invocationsDone() bool {
	if len(mmGetOrderByID.expectations) == 0 && mmGetOrderByID.defaultExpectation == nil && mmGetOrderByID.mock.funcGetOrderByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrderByID.mock.afterGetOrderByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrderByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrderByID implements mm_usecase.orderRepository
func (mmGetOrderByID *RepositoryMock) GetOrderByID(id int) (op1 *domain.Order, err error) {
	mm_atomic.AddUint64(&mmGetOrderByID.beforeGetOrderByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrderByID.afterGetOrderByIDCounter, 1)

	mmGetOrderByID.t.Helper()

	if mmGetOrderByID.inspectFuncGetOrderByID != nil {
		mmGetOrderByID.inspectFuncGetOrderByID(id)
	}

	mm_params := RepositoryMockGetOrderByIDParams{id}

	// Record call args
	mmGetOrderByID.GetOrderByIDMock.mutex.Lock()
	mmGetOrderByID.GetOrderByIDMock.callArgs = append(mmGetOrderByID.GetOrderByIDMock.callArgs, &mm_params)
	mmGetOrderByID.GetOrderByIDMock.mutex.Unlock()

	for _, e := range mmGetOrderByID.GetOrderByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetOrderByID.GetOrderByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrderByID.GetOrderByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrderByID.GetOrderByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrderByID.GetOrderByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetOrderByIDParams{id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetOrderByID.t.Errorf("RepositoryMock.GetOrderByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrderByID.GetOrderByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrderByID.t.Errorf("RepositoryMock.GetOrderByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrderByID.GetOrderByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrderByID.GetOrderByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrderByID.t.Fatal("No results are set for the RepositoryMock.GetOrderByID")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetOrderByID.funcGetOrderByID != nil {
		return mmGetOrderByID.funcGetOrderByID(id)
	}
	mmGetOrderByID.t.Fatalf("Unexpected call to RepositoryMock.GetOrderByID. %v", id)
	return
}

// GetOrderByIDAfterCounter returns a count of finished RepositoryMock.GetOrderByID invocations
func (mmGetOrderByID *RepositoryMock) GetOrderByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderByID.afterGetOrderByIDCounter)
}

// GetOrderByIDBeforeCounter returns a count of RepositoryMock.GetOrderByID invocations
func (mmGetOrderByID *RepositoryMock) GetOrderByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderByID.beforeGetOrderByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetOrderByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrderByID *mRepositoryMockGetOrderByID) Calls() []*RepositoryMockGetOrderByIDParams {
	mmGetOrderByID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetOrderByIDParams, len(mmGetOrderByID.callArgs))
	copy(argCopy, mmGetOrderByID.callArgs)

	mmGetOrderByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderByIDDone returns true if the count of the GetOrderByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetOrderByIDDone() bool {
	if m.GetOrderByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrderByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrderByIDMock.invocationsDone()
}

// MinimockGetOrderByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetOrderByIDInspect() {
	for _, e := range m.GetOrderByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetOrderByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrderByIDCounter := mm_atomic.LoadUint64(&m.afterGetOrderByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderByIDMock.defaultExpectation != nil && afterGetOrderByIDCounter < 1 {
		if m.GetOrderByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetOrderByID at\n%s", m.GetOrderByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetOrderByID at\n%s with params: %#v", m.GetOrderByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetOrderByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderByID != nil && afterGetOrderByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetOrderByID at\n%s", m.funcGetOrderByIDOrigin)
	}

	if !m.GetOrderByIDMock.invocationsDone() && afterGetOrderByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetOrderByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrderByIDMock.expectedInvocations), m.GetOrderByIDMock.expectedInvocationsOrigin, afterGetOrderByIDCounter)
	}
}

type mRepositoryMockGetOrdersByID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetOrdersByIDExpectation
	expectations       []*RepositoryMockGetOrdersByIDExpectation

	callArgs []*RepositoryMockGetOrdersByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetOrdersByIDExpectation specifies expectation struct of the orderRepository.GetOrdersByID
type RepositoryMockGetOrdersByIDExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetOrdersByIDParams
	paramPtrs          *RepositoryMockGetOrdersByIDParamPtrs
	expectationOrigins RepositoryMockGetOrdersByIDExpectationOrigins
	results            *RepositoryMockGetOrdersByIDResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetOrdersByIDParams contains parameters of the orderRepository.GetOrdersByID
type RepositoryMockGetOrdersByIDParams struct {
	ids []int
}

// RepositoryMockGetOrdersByIDParamPtrs contains pointers to parameters of the orderRepository.GetOrdersByID
type RepositoryMockGetOrdersByIDParamPtrs struct {
	ids *[]int
}

// RepositoryMockGetOrdersByIDResults contains results of the orderRepository.GetOrdersByID
type RepositoryMockGetOrdersByIDResults struct {
	opa1 []*domain.Order
	err  error
}

// RepositoryMockGetOrdersByIDOrigins contains origins of expectations of the orderRepository.GetOrdersByID
type RepositoryMockGetOrdersByIDExpectationOrigins struct {
	origin    string
	originIds string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrdersByID *mRepositoryMockGetOrdersByID) Optional() *mRepositoryMockGetOrdersByID {
	mmGetOrdersByID.optional = true
	return mmGetOrdersByID
}

// Expect sets up expected params for orderRepository.GetOrdersByID
func (mmGetOrdersByID *mRepositoryMockGetOrdersByID) Expect(ids []int) *mRepositoryMockGetOrdersByID {
	if mmGetOrdersByID.mock.funcGetOrdersByID != nil {
		mmGetOrdersByID.mock.t.Fatalf("RepositoryMock.GetOrdersByID mock is already set by Set")
	}

	if mmGetOrdersByID.defaultExpectation == nil {
		mmGetOrdersByID.defaultExpectation = &RepositoryMockGetOrdersByIDExpectation{}
	}

	if mmGetOrdersByID.defaultExpectation.paramPtrs != nil {
		mmGetOrdersByID.mock.t.Fatalf("RepositoryMock.GetOrdersByID mock is already set by ExpectParams functions")
	}

	mmGetOrdersByID.defaultExpectation.params = &RepositoryMockGetOrdersByIDParams{ids}
	mmGetOrdersByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrdersByID.expectations {
		if minimock.Equal(e.params, mmGetOrdersByID.defaultExpectation.params) {
			mmGetOrdersByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrdersByID.defaultExpectation.params)
		}
	}

	return mmGetOrdersByID
}

// ExpectIdsParam1 sets up expected param ids for orderRepository.GetOrdersByID
func (mmGetOrdersByID *mRepositoryMockGetOrdersByID) ExpectIdsParam1(ids []int) *mRepositoryMockGetOrdersByID {
	if mmGetOrdersByID.mock.funcGetOrdersByID != nil {
		mmGetOrdersByID.mock.t.Fatalf("RepositoryMock.GetOrdersByID mock is already set by Set")
	}

	if mmGetOrdersByID.defaultExpectation == nil {
		mmGetOrdersByID.defaultExpectation = &RepositoryMockGetOrdersByIDExpectation{}
	}

	if mmGetOrdersByID.defaultExpectation.params != nil {
		mmGetOrdersByID.mock.t.Fatalf("RepositoryMock.GetOrdersByID mock is already set by Expect")
	}

	if mmGetOrdersByID.defaultExpectation.paramPtrs == nil {
		mmGetOrdersByID.defaultExpectation.paramPtrs = &RepositoryMockGetOrdersByIDParamPtrs{}
	}
	mmGetOrdersByID.defaultExpectation.paramPtrs.ids = &ids
	mmGetOrdersByID.defaultExpectation.expectationOrigins.originIds = minimock.CallerInfo(1)

	return mmGetOrdersByID
}

// Inspect accepts an inspector function that has same arguments as the orderRepository.GetOrdersByID
func (mmGetOrdersByID *mRepositoryMockGetOrdersByID) Inspect(f func(ids []int)) *mRepositoryMockGetOrdersByID {
	if mmGetOrdersByID.mock.inspectFuncGetOrdersByID != nil {
		mmGetOrdersByID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetOrdersByID")
	}

	mmGetOrdersByID.mock.inspectFuncGetOrdersByID = f

	return mmGetOrdersByID
}

// Return sets up results that will be returned by orderRepository.GetOrdersByID
func (mmGetOrdersByID *mRepositoryMockGetOrdersByID) Return(opa1 []*domain.Order, err error) *RepositoryMock {
	if mmGetOrdersByID.mock.funcGetOrdersByID != nil {
		mmGetOrdersByID.mock.t.Fatalf("RepositoryMock.GetOrdersByID mock is already set by Set")
	}

	if mmGetOrdersByID.defaultExpectation == nil {
		mmGetOrdersByID.defaultExpectation = &RepositoryMockGetOrdersByIDExpectation{mock: mmGetOrdersByID.mock}
	}
	mmGetOrdersByID.defaultExpectation.results = &RepositoryMockGetOrdersByIDResults{opa1, err}
	mmGetOrdersByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrdersByID.mock
}

// Set uses given function f to mock the orderRepository.GetOrdersByID method
func (mmGetOrdersByID *mRepositoryMockGetOrdersByID) Set(f func(ids []int) (opa1 []*domain.Order, err error)) *RepositoryMock {
	if mmGetOrdersByID.defaultExpectation != nil {
		mmGetOrdersByID.mock.t.Fatalf("Default expectation is already set for the orderRepository.GetOrdersByID method")
	}

	if len(mmGetOrdersByID.expectations) > 0 {
		mmGetOrdersByID.mock.t.Fatalf("Some expectations are already set for the orderRepository.GetOrdersByID method")
	}

	mmGetOrdersByID.mock.funcGetOrdersByID = f
	mmGetOrdersByID.mock.funcGetOrdersByIDOrigin = minimock.CallerInfo(1)
	return mmGetOrdersByID.mock
}

// When sets expectation for the orderRepository.GetOrdersByID which will trigger the result defined by the following
// Then helper
func (mmGetOrdersByID *mRepositoryMockGetOrdersByID) When(ids []int) *RepositoryMockGetOrdersByIDExpectation {
	if mmGetOrdersByID.mock.funcGetOrdersByID != nil {
		mmGetOrdersByID.mock.t.Fatalf("RepositoryMock.GetOrdersByID mock is already set by Set")
	}

	expectation := &RepositoryMockGetOrdersByIDExpectation{
		mock:               mmGetOrdersByID.mock,
		params:             &RepositoryMockGetOrdersByIDParams{ids},
		expectationOrigins: RepositoryMockGetOrdersByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrdersByID.expectations = append(mmGetOrdersByID.expectations, expectation)
	return expectation
}

// Then sets up orderRepository.GetOrdersByID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetOrdersByIDExpectation) Then(opa1 []*domain.Order, err error) *RepositoryMock {
	e.results = &RepositoryMockGetOrdersByIDResults{opa1, err}
	return e.mock
}

// Times sets number of times orderRepository.GetOrdersByID should be invoked
func (mmGetOrdersByID *mRepositoryMockGetOrdersByID) Times(n uint64) *mRepositoryMockGetOrdersByID {
	if n == 0 {
		mmGetOrdersByID.mock.t.Fatalf("Times of RepositoryMock.GetOrdersByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrdersByID.expectedInvocations, n)
	mmGetOrdersByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrdersByID
}

func (mmGetOrdersByID *mRepositoryMockGetOrdersByID) invocationsDone() bool {
	if len(mmGetOrdersByID.expectations) == 0 && mmGetOrdersByID.defaultExpectation == nil && mmGetOrdersByID.mock.funcGetOrdersByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrdersByID.mock.afterGetOrdersByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrdersByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrdersByID implements mm_usecase.orderRepository
func (mmGetOrdersByID *RepositoryMock) GetOrdersByID(ids []int) (opa1 []*domain.Order, err error) {
	mm_atomic.AddUint64(&mmGetOrdersByID.beforeGetOrdersByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrdersByID.afterGetOrdersByIDCounter, 1)

	mmGetOrdersByID.t.Helper()

	if mmGetOrdersByID.inspectFuncGetOrdersByID != nil {
		mmGetOrdersByID.inspectFuncGetOrdersByID(ids)
	}

	mm_params := RepositoryMockGetOrdersByIDParams{ids}

	// Record call args
	mmGetOrdersByID.GetOrdersByIDMock.mutex.Lock()
	mmGetOrdersByID.GetOrdersByIDMock.callArgs = append(mmGetOrdersByID.GetOrdersByIDMock.callArgs, &mm_params)
	mmGetOrdersByID.GetOrdersByIDMock.mutex.Unlock()

	for _, e := range mmGetOrdersByID.GetOrdersByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.opa1, e.results.err
		}
	}

	if mmGetOrdersByID.GetOrdersByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrdersByID.GetOrdersByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrdersByID.GetOrdersByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrdersByID.GetOrdersByIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetOrdersByIDParams{ids}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ids != nil && !minimock.Equal(*mm_want_ptrs.ids, mm_got.ids) {
				mmGetOrdersByID.t.Errorf("RepositoryMock.GetOrdersByID got unexpected parameter ids, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrdersByID.GetOrdersByIDMock.defaultExpectation.expectationOrigins.originIds, *mm_want_ptrs.ids, mm_got.ids, minimock.Diff(*mm_want_ptrs.ids, mm_got.ids))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrdersByID.t.Errorf("RepositoryMock.GetOrdersByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrdersByID.GetOrdersByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrdersByID.GetOrdersByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrdersByID.t.Fatal("No results are set for the RepositoryMock.GetOrdersByID")
		}
		return (*mm_results).opa1, (*mm_results).err
	}
	if mmGetOrdersByID.funcGetOrdersByID != nil {
		return mmGetOrdersByID.funcGetOrdersByID(ids)
	}
	mmGetOrdersByID.t.Fatalf("Unexpected call to RepositoryMock.GetOrdersByID. %v", ids)
	return
}

// GetOrdersByIDAfterCounter returns a count of finished RepositoryMock.GetOrdersByID invocations
func (mmGetOrdersByID *RepositoryMock) GetOrdersByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrdersByID.afterGetOrdersByIDCounter)
}

// GetOrdersByIDBeforeCounter returns a count of RepositoryMock.GetOrdersByID invocations
func (mmGetOrdersByID *RepositoryMock) GetOrdersByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrdersByID.beforeGetOrdersByIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetOrdersByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrdersByID *mRepositoryMockGetOrdersByID) Calls() []*RepositoryMockGetOrdersByIDParams {
	mmGetOrdersByID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetOrdersByIDParams, len(mmGetOrdersByID.callArgs))
	copy(argCopy, mmGetOrdersByID.callArgs)

	mmGetOrdersByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrdersByIDDone returns true if the count of the GetOrdersByID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetOrdersByIDDone() bool {
	if m.GetOrdersByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrdersByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrdersByIDMock.invocationsDone()
}

// MinimockGetOrdersByIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetOrdersByIDInspect() {
	for _, e := range m.GetOrdersByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetOrdersByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrdersByIDCounter := mm_atomic.LoadUint64(&m.afterGetOrdersByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrdersByIDMock.defaultExpectation != nil && afterGetOrdersByIDCounter < 1 {
		if m.GetOrdersByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetOrdersByID at\n%s", m.GetOrdersByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetOrdersByID at\n%s with params: %#v", m.GetOrdersByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetOrdersByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrdersByID != nil && afterGetOrdersByIDCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetOrdersByID at\n%s", m.funcGetOrdersByIDOrigin)
	}

	if !m.GetOrdersByIDMock.invocationsDone() && afterGetOrdersByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetOrdersByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrdersByIDMock.expectedInvocations), m.GetOrdersByIDMock.expectedInvocationsOrigin, afterGetOrdersByIDCounter)
	}
}

type mRepositoryMockGetRefundsList struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetRefundsListExpectation
	expectations       []*RepositoryMockGetRefundsListExpectation

	callArgs []*RepositoryMockGetRefundsListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetRefundsListExpectation specifies expectation struct of the orderRepository.GetRefundsList
type RepositoryMockGetRefundsListExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetRefundsListParams
	paramPtrs          *RepositoryMockGetRefundsListParamPtrs
	expectationOrigins RepositoryMockGetRefundsListExpectationOrigins
	results            *RepositoryMockGetRefundsListResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetRefundsListParams contains parameters of the orderRepository.GetRefundsList
type RepositoryMockGetRefundsListParams struct {
	limit  int
	offset int
}

// RepositoryMockGetRefundsListParamPtrs contains pointers to parameters of the orderRepository.GetRefundsList
type RepositoryMockGetRefundsListParamPtrs struct {
	limit  *int
	offset *int
}

// RepositoryMockGetRefundsListResults contains results of the orderRepository.GetRefundsList
type RepositoryMockGetRefundsListResults struct {
	opa1 []*domain.Order
	err  error
}

// RepositoryMockGetRefundsListOrigins contains origins of expectations of the orderRepository.GetRefundsList
type RepositoryMockGetRefundsListExpectationOrigins struct {
	origin       string
	originLimit  string
	originOffset string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetRefundsList *mRepositoryMockGetRefundsList) Optional() *mRepositoryMockGetRefundsList {
	mmGetRefundsList.optional = true
	return mmGetRefundsList
}

// Expect sets up expected params for orderRepository.GetRefundsList
func (mmGetRefundsList *mRepositoryMockGetRefundsList) Expect(limit int, offset int) *mRepositoryMockGetRefundsList {
	if mmGetRefundsList.mock.funcGetRefundsList != nil {
		mmGetRefundsList.mock.t.Fatalf("RepositoryMock.GetRefundsList mock is already set by Set")
	}

	if mmGetRefundsList.defaultExpectation == nil {
		mmGetRefundsList.defaultExpectation = &RepositoryMockGetRefundsListExpectation{}
	}

	if mmGetRefundsList.defaultExpectation.paramPtrs != nil {
		mmGetRefundsList.mock.t.Fatalf("RepositoryMock.GetRefundsList mock is already set by ExpectParams functions")
	}

	mmGetRefundsList.defaultExpectation.params = &RepositoryMockGetRefundsListParams{limit, offset}
	mmGetRefundsList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetRefundsList.expectations {
		if minimock.Equal(e.params, mmGetRefundsList.defaultExpectation.params) {
			mmGetRefundsList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRefundsList.defaultExpectation.params)
		}
	}

	return mmGetRefundsList
}

// ExpectLimitParam1 sets up expected param limit for orderRepository.GetRefundsList
func (mmGetRefundsList *mRepositoryMockGetRefundsList) ExpectLimitParam1(limit int) *mRepositoryMockGetRefundsList {
	if mmGetRefundsList.mock.funcGetRefundsList != nil {
		mmGetRefundsList.mock.t.Fatalf("RepositoryMock.GetRefundsList mock is already set by Set")
	}

	if mmGetRefundsList.defaultExpectation == nil {
		mmGetRefundsList.defaultExpectation = &RepositoryMockGetRefundsListExpectation{}
	}

	if mmGetRefundsList.defaultExpectation.params != nil {
		mmGetRefundsList.mock.t.Fatalf("RepositoryMock.GetRefundsList mock is already set by Expect")
	}

	if mmGetRefundsList.defaultExpectation.paramPtrs == nil {
		mmGetRefundsList.defaultExpectation.paramPtrs = &RepositoryMockGetRefundsListParamPtrs{}
	}
	mmGetRefundsList.defaultExpectation.paramPtrs.limit = &limit
	mmGetRefundsList.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmGetRefundsList
}

// ExpectOffsetParam2 sets up expected param offset for orderRepository.GetRefundsList
func (mmGetRefundsList *mRepositoryMockGetRefundsList) ExpectOffsetParam2(offset int) *mRepositoryMockGetRefundsList {
	if mmGetRefundsList.mock.funcGetRefundsList != nil {
		mmGetRefundsList.mock.t.Fatalf("RepositoryMock.GetRefundsList mock is already set by Set")
	}

	if mmGetRefundsList.defaultExpectation == nil {
		mmGetRefundsList.defaultExpectation = &RepositoryMockGetRefundsListExpectation{}
	}

	if mmGetRefundsList.defaultExpectation.params != nil {
		mmGetRefundsList.mock.t.Fatalf("RepositoryMock.GetRefundsList mock is already set by Expect")
	}

	if mmGetRefundsList.defaultExpectation.paramPtrs == nil {
		mmGetRefundsList.defaultExpectation.paramPtrs = &RepositoryMockGetRefundsListParamPtrs{}
	}
	mmGetRefundsList.defaultExpectation.paramPtrs.offset = &offset
	mmGetRefundsList.defaultExpectation.expectationOrigins.originOffset = minimock.CallerInfo(1)

	return mmGetRefundsList
}

// Inspect accepts an inspector function that has same arguments as the orderRepository.GetRefundsList
func (mmGetRefundsList *mRepositoryMockGetRefundsList) Inspect(f func(limit int, offset int)) *mRepositoryMockGetRefundsList {
	if mmGetRefundsList.mock.inspectFuncGetRefundsList != nil {
		mmGetRefundsList.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetRefundsList")
	}

	mmGetRefundsList.mock.inspectFuncGetRefundsList = f

	return mmGetRefundsList
}

// Return sets up results that will be returned by orderRepository.GetRefundsList
func (mmGetRefundsList *mRepositoryMockGetRefundsList) Return(opa1 []*domain.Order, err error) *RepositoryMock {
	if mmGetRefundsList.mock.funcGetRefundsList != nil {
		mmGetRefundsList.mock.t.Fatalf("RepositoryMock.GetRefundsList mock is already set by Set")
	}

	if mmGetRefundsList.defaultExpectation == nil {
		mmGetRefundsList.defaultExpectation = &RepositoryMockGetRefundsListExpectation{mock: mmGetRefundsList.mock}
	}
	mmGetRefundsList.defaultExpectation.results = &RepositoryMockGetRefundsListResults{opa1, err}
	mmGetRefundsList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetRefundsList.mock
}

// Set uses given function f to mock the orderRepository.GetRefundsList method
func (mmGetRefundsList *mRepositoryMockGetRefundsList) Set(f func(limit int, offset int) (opa1 []*domain.Order, err error)) *RepositoryMock {
	if mmGetRefundsList.defaultExpectation != nil {
		mmGetRefundsList.mock.t.Fatalf("Default expectation is already set for the orderRepository.GetRefundsList method")
	}

	if len(mmGetRefundsList.expectations) > 0 {
		mmGetRefundsList.mock.t.Fatalf("Some expectations are already set for the orderRepository.GetRefundsList method")
	}

	mmGetRefundsList.mock.funcGetRefundsList = f
	mmGetRefundsList.mock.funcGetRefundsListOrigin = minimock.CallerInfo(1)
	return mmGetRefundsList.mock
}

// When sets expectation for the orderRepository.GetRefundsList which will trigger the result defined by the following
// Then helper
func (mmGetRefundsList *mRepositoryMockGetRefundsList) When(limit int, offset int) *RepositoryMockGetRefundsListExpectation {
	if mmGetRefundsList.mock.funcGetRefundsList != nil {
		mmGetRefundsList.mock.t.Fatalf("RepositoryMock.GetRefundsList mock is already set by Set")
	}

	expectation := &RepositoryMockGetRefundsListExpectation{
		mock:               mmGetRefundsList.mock,
		params:             &RepositoryMockGetRefundsListParams{limit, offset},
		expectationOrigins: RepositoryMockGetRefundsListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetRefundsList.expectations = append(mmGetRefundsList.expectations, expectation)
	return expectation
}

// Then sets up orderRepository.GetRefundsList return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetRefundsListExpectation) Then(opa1 []*domain.Order, err error) *RepositoryMock {
	e.results = &RepositoryMockGetRefundsListResults{opa1, err}
	return e.mock
}

// Times sets number of times orderRepository.GetRefundsList should be invoked
func (mmGetRefundsList *mRepositoryMockGetRefundsList) Times(n uint64) *mRepositoryMockGetRefundsList {
	if n == 0 {
		mmGetRefundsList.mock.t.Fatalf("Times of RepositoryMock.GetRefundsList mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetRefundsList.expectedInvocations, n)
	mmGetRefundsList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetRefundsList
}

func (mmGetRefundsList *mRepositoryMockGetRefundsList) invocationsDone() bool {
	if len(mmGetRefundsList.expectations) == 0 && mmGetRefundsList.defaultExpectation == nil && mmGetRefundsList.mock.funcGetRefundsList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetRefundsList.mock.afterGetRefundsListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetRefundsList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetRefundsList implements mm_usecase.orderRepository
func (mmGetRefundsList *RepositoryMock) GetRefundsList(limit int, offset int) (opa1 []*domain.Order, err error) {
	mm_atomic.AddUint64(&mmGetRefundsList.beforeGetRefundsListCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRefundsList.afterGetRefundsListCounter, 1)

	mmGetRefundsList.t.Helper()

	if mmGetRefundsList.inspectFuncGetRefundsList != nil {
		mmGetRefundsList.inspectFuncGetRefundsList(limit, offset)
	}

	mm_params := RepositoryMockGetRefundsListParams{limit, offset}

	// Record call args
	mmGetRefundsList.GetRefundsListMock.mutex.Lock()
	mmGetRefundsList.GetRefundsListMock.callArgs = append(mmGetRefundsList.GetRefundsListMock.callArgs, &mm_params)
	mmGetRefundsList.GetRefundsListMock.mutex.Unlock()

	for _, e := range mmGetRefundsList.GetRefundsListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.opa1, e.results.err
		}
	}

	if mmGetRefundsList.GetRefundsListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRefundsList.GetRefundsListMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRefundsList.GetRefundsListMock.defaultExpectation.params
		mm_want_ptrs := mmGetRefundsList.GetRefundsListMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetRefundsListParams{limit, offset}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetRefundsList.t.Errorf("RepositoryMock.GetRefundsList got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRefundsList.GetRefundsListMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

			if mm_want_ptrs.offset != nil && !minimock.Equal(*mm_want_ptrs.offset, mm_got.offset) {
				mmGetRefundsList.t.Errorf("RepositoryMock.GetRefundsList got unexpected parameter offset, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetRefundsList.GetRefundsListMock.defaultExpectation.expectationOrigins.originOffset, *mm_want_ptrs.offset, mm_got.offset, minimock.Diff(*mm_want_ptrs.offset, mm_got.offset))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRefundsList.t.Errorf("RepositoryMock.GetRefundsList got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetRefundsList.GetRefundsListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRefundsList.GetRefundsListMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRefundsList.t.Fatal("No results are set for the RepositoryMock.GetRefundsList")
		}
		return (*mm_results).opa1, (*mm_results).err
	}
	if mmGetRefundsList.funcGetRefundsList != nil {
		return mmGetRefundsList.funcGetRefundsList(limit, offset)
	}
	mmGetRefundsList.t.Fatalf("Unexpected call to RepositoryMock.GetRefundsList. %v %v", limit, offset)
	return
}

// GetRefundsListAfterCounter returns a count of finished RepositoryMock.GetRefundsList invocations
func (mmGetRefundsList *RepositoryMock) GetRefundsListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefundsList.afterGetRefundsListCounter)
}

// GetRefundsListBeforeCounter returns a count of RepositoryMock.GetRefundsList invocations
func (mmGetRefundsList *RepositoryMock) GetRefundsListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRefundsList.beforeGetRefundsListCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetRefundsList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRefundsList *mRepositoryMockGetRefundsList) Calls() []*RepositoryMockGetRefundsListParams {
	mmGetRefundsList.mutex.RLock()

	argCopy := make([]*RepositoryMockGetRefundsListParams, len(mmGetRefundsList.callArgs))
	copy(argCopy, mmGetRefundsList.callArgs)

	mmGetRefundsList.mutex.RUnlock()

	return argCopy
}

// MinimockGetRefundsListDone returns true if the count of the GetRefundsList invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetRefundsListDone() bool {
	if m.GetRefundsListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetRefundsListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetRefundsListMock.invocationsDone()
}

// MinimockGetRefundsListInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetRefundsListInspect() {
	for _, e := range m.GetRefundsListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetRefundsList at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetRefundsListCounter := mm_atomic.LoadUint64(&m.afterGetRefundsListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetRefundsListMock.defaultExpectation != nil && afterGetRefundsListCounter < 1 {
		if m.GetRefundsListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetRefundsList at\n%s", m.GetRefundsListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetRefundsList at\n%s with params: %#v", m.GetRefundsListMock.defaultExpectation.expectationOrigins.origin, *m.GetRefundsListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRefundsList != nil && afterGetRefundsListCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetRefundsList at\n%s", m.funcGetRefundsListOrigin)
	}

	if !m.GetRefundsListMock.invocationsDone() && afterGetRefundsListCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetRefundsList at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetRefundsListMock.expectedInvocations), m.GetRefundsListMock.expectedInvocationsOrigin, afterGetRefundsListCounter)
	}
}

type mRepositoryMockUpdate struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateExpectation
	expectations       []*RepositoryMockUpdateExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateExpectation specifies expectation struct of the orderRepository.Update
type RepositoryMockUpdateExpectation struct {
	mock *RepositoryMock

	results      *RepositoryMockUpdateResults
	returnOrigin string
	Counter      uint64
}

// RepositoryMockUpdateResults contains results of the orderRepository.Update
type RepositoryMockUpdateResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mRepositoryMockUpdate) Optional() *mRepositoryMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for orderRepository.Update
func (mmUpdate *mRepositoryMockUpdate) Expect() *mRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &RepositoryMockUpdateExpectation{}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the orderRepository.Update
func (mmUpdate *mRepositoryMockUpdate) Inspect(f func()) *mRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by orderRepository.Update
func (mmUpdate *mRepositoryMockUpdate) Return(err error) *RepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &RepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &RepositoryMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the orderRepository.Update method
func (mmUpdate *mRepositoryMockUpdate) Set(f func() (err error)) *RepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the orderRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the orderRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Times sets number of times orderRepository.Update should be invoked
func (mmUpdate *mRepositoryMockUpdate) Times(n uint64) *mRepositoryMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of RepositoryMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mRepositoryMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_usecase.orderRepository
func (mmUpdate *RepositoryMock) Update() (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate()
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the RepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate()
	}
	mmUpdate.t.Fatalf("Unexpected call to RepositoryMock.Update.")
	return
}

// UpdateAfterCounter returns a count of finished RepositoryMock.Update invocations
func (mmUpdate *RepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of RepositoryMock.Update invocations
func (mmUpdate *RepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RepositoryMock.Update")
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddOrderInspect()

			m.MinimockGetClientOrdersListInspect()

			m.MinimockGetOrderByIDInspect()

			m.MinimockGetOrdersByIDInspect()

			m.MinimockGetRefundsListInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddOrderDone() &&
		m.MinimockGetClientOrdersListDone() &&
		m.MinimockGetOrderByIDDone() &&
		m.MinimockGetOrdersByIDDone() &&
		m.MinimockGetRefundsListDone() &&
		m.MinimockUpdateDone()
}
